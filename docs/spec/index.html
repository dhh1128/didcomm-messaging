
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

            <title>DIDComm Messaging Specification</title>
            <link href="../spec-up/compiled/head.css" rel="stylesheet"/>
                <script src="../spec-up/compiled/head.js"></script>
          </head>
          <body features="source logo">
            
            <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <symbol id="github" viewBox="0 0 20 20">
    <path d="M10 0.247c-5.522 0-10 4.477-10 10 0 4.418 2.865 8.167 6.839 9.489 0.5 0.093 0.683-0.217 0.683-0.481 0-0.238-0.009-1.026-0.014-1.862-2.782 0.605-3.369-1.18-3.369-1.18-0.455-1.156-1.11-1.463-1.11-1.463-0.907-0.621 0.069-0.608 0.069-0.608 1.004 0.071 1.533 1.031 1.533 1.031 0.892 1.529 2.339 1.087 2.91 0.831 0.090-0.646 0.349-1.087 0.635-1.337-2.221-0.253-4.556-1.11-4.556-4.942 0-1.092 0.391-1.984 1.030-2.684-0.104-0.252-0.446-1.269 0.097-2.646 0 0 0.84-0.269 2.751 1.025 0.798-0.222 1.653-0.333 2.503-0.337 0.85 0.004 1.706 0.115 2.505 0.337 1.909-1.294 2.747-1.025 2.747-1.025 0.544 1.378 0.202 2.395 0.098 2.646 0.641 0.7 1.029 1.592 1.029 2.684 0 3.841-2.339 4.687-4.566 4.934 0.359 0.31 0.678 0.919 0.678 1.852 0 1.338-0.012 2.415-0.012 2.744 0 0.266 0.18 0.578 0.687 0.48 3.971-1.324 6.833-5.071 6.833-9.488 0-5.523-4.477-10-10-10z"></path>
  </symbol>
  <symbol id="nested_list" viewBox="0 0 37 32">
    <path d="M0 2.286c0-1.262 1.023-2.286 2.286-2.286s2.286 1.023 2.286 2.286c0 1.262-1.023 2.286-2.286 2.286s-2.286-1.023-2.286-2.286zM9.143 0h27.429v4.571h-27.429zM9.143 11.429c0-1.262 1.023-2.286 2.286-2.286s2.286 1.023 2.286 2.286c0 1.262-1.023 2.286-2.286 2.286s-2.286-1.023-2.286-2.286zM18.286 9.143h18.286v4.571h-18.286zM9.143 29.714c0-1.262 1.023-2.286 2.286-2.286s2.286 1.023 2.286 2.286c0 1.262-1.023 2.286-2.286 2.286s-2.286-1.023-2.286-2.286zM18.286 27.429h18.286v4.571h-18.286zM18.286 20.571c0-1.262 1.023-2.286 2.286-2.286s2.286 1.023 2.286 2.286c0 1.262-1.023 2.286-2.286 2.286s-2.286-1.023-2.286-2.286zM27.429 18.286h9.143v4.571h-9.143z"></path>
  </symbol>
</svg>

            <main>

              <header id="header" class="panel-header">
                <span id="toc_toggle" panel-toggle="toc">
                  <svg icon><use xlink:href="#nested_list"></use></svg>
                </span>
                <a id="logo" href="https://identity.foundation">
                  <img src="https://rawcdn.githack.com/decentralized-identity/decentralized-identity.github.io/a3ca39717e440302d1fd99a796e7f00e1c42eb2d/images/logo-flat.svg" />
                </a>
                <span issue-count animate panel-toggle="repo_issues">
                  <svg icon><use xlink:href="#github"></use></svg>
                </span>
              </header>

              <article id="content">
                <h1 id="didcomm-messaging"><a class="toc-anchor" href="#didcomm-messaging">§</a> DIDComm Messaging</h1>
<p><strong>Specification Status:</strong> Editor’s Draft</p>
<p><strong>Latest published version:</strong>
<a href="https://identity.foundation/didcomm-messaging/docs/spec">identity.foundation/didcomm-messaging/docs/spec</a></p>
<p><strong>Editors:</strong></p>
<p><strong>Contributors:</strong> Daniel Hardman</p>
<dl>
<dt><strong>Participate:</strong></dt>
<dd><a href="https://github.com/decentralized-identity/didcomm-messaging">GitHub repo</a></dd>
<dd><a href="https://github.com/decentralized-identity/didcomm-messaging/issues">File a bug</a></dd>
<dd><a href="https://github.com/decentralized-identity/didcomm-messaging/commits/master">Commit history</a></dd>
</dl>
<hr>
<h2 id="purpose-and-scope"><a class="toc-anchor" href="#purpose-and-scope">§</a> Purpose and Scope</h2>
<p>The purpose of DIDComm is to provide a secure, private communication methodology built atop the decentralized design of <a href="https://www.w3.org/TR/did-core/">DIDs</a>.</p>
<p>Other robust mechanisms for secure communication already exist. However, most rely on key registries, identity providers, certificate authorities, browser or app vendors, or similarly centralized assumptions. They also tend to be tied to a single transport, making it difficult to use the same solution for human and machine conversations, online and offline, simplex and duplex, across a broad set of modalities. The net result is that they perpetuate an asymmetry between institutions and ordinary people. The former maintain certificates and always-connected servers, and publish APIs under terms and conditions they dictate; the latter suffer with usernames and passwords, poor interoperability, and a Hobson’s choice between privacy and convenience.</p>
<p>DIDComm can fix this. Using DIDComm, individuals on semi-connected mobile devices become full peers of highly available web servers operated by IT experts. Registration is self-service, intermediaries require little trust, and no terms and conditions apply.</p>
<p>DIDComm enables higher-order protocols that inherit its security, privacy, decentralization, and transport independence. Examples include exchanging verifiable credentials, creating and maintaining relationships, buying and selling, scheduling events, negotiating contracts, voting, presenting tickets for travel, applying to employers or schools or banks, arranging healthcare, and playing games. Like web services atop HTTP, the possibilities are endless; unlike web services atop HTTP, many parties can participate without being clients of a central server, and they can use a mixture of connectivity models and technologies.</p>
<h3 id="overview"><a class="toc-anchor" href="#overview">§</a> Overview</h3>
<p>To understand how DIDComm works, consider a situation where Alice wants to negotiate with Bob to sell something online. Because DIDComm, not direct human communication, is the methodology in this example, Alice’s software agent and Bob’s software agent are going to exchange a series of messages.</p>
<p>Alice may just press a button and be unaware of details, but underneath, her agent begins by preparing a plaintext JSON message about the proposed sale. (The particulars are irrelevant here, but would be described in the spec for a higher-level “sell something” protocol that takes DIDComm as its foundation.) Alice’s agent then looks up Bob’s DID Doc to access two key pieces of information:</p>
<ul>
<li>An endpoint (web, email, etc) where messages can be delivered to Bob.</li>
<li>The public key that Bob’s agent is using in the Alice:Bob relationship.</li>
</ul>
<p>Now Alice’s agent uses Bob’s public key to encrypt the plaintext so that only Bob’s agent can read it, adding authentication with its own private key. The agent arranges delivery to Bob. This “arranging” can involve various hops and intermediaries. It can be complex. (See <a href="/guide#routing">Routing in the Implementers Guide</a>.)</p>
<p>Bob’s agent eventually receives and decrypts the message, authenticating its origin as Alice using her public key. It prepares its response and routes it back using a reciprocal process (plaintext → lookup endpoint and public key for Alice → encrypt with authentication → arrange delivery).</p>
<p>That’s the essence, in the most common scenarios. However, it does not fit all DIDComm interactions:</p>
<ul>
<li>DIDComm doesn’t always involve turn-taking and request-response.</li>
<li>DIDComm interactions can involve more than 2 parties, and the parties are not always individuals.</li>
<li>DIDComm may include formats other than JSON.</li>
</ul>
<p>Before we provide more details, let’s explore what drives the design of DIDComm.</p>
<h3 id="specific-requirements"><a class="toc-anchor" href="#specific-requirements">§</a> Specific Requirements</h3>
<p>The DIDComm design attempts to be:</p>
<ol>
<li><strong>Secure</strong> (tamper-proof; uses best-of-breed crypto; allows parties to talk both on and off the record…)</li>
<li><strong>Private</strong> (third parties can’t learn who’s communicating about what, when; lets sender be anonymous to recipient)</li>
<li><strong>Decentralized</strong> (derives trust for encryption, signing, authn, and authz from control of DIDs rather than oracles like CAs, IDPs, etc; usable at the edge)</li>
<li><strong>Transport-agnostic</strong> (usable over HTTPS 1.x and 2.0, WebSockets, BlueTooth, chat, push notifications, AMQP, SMTP, NFC, sneakernet, snail mail; supports both simplex and duplex; works offline; doesn’t assume client-server or synchronous or real-time; allows paired or n-wise or public broadcast usage)</li>
<li><strong>Routable</strong> (like email, A can talk to B without a direct connection to B; allows mixed and dynamic transports; passes through mix networks and other generic infrastructure that sees only payload BLOBs)</li>
<li><strong>Interoperable</strong> (works across programming languages, blockchains, vendors, OS/platforms, networks, legal jurisdictions, geos, cryptographies, and hardware–as well as across time; avoids vendor lock-in)</li>
<li><strong>Extensible</strong> (lets devs start simple without heavy learning or dependencies; customize easily; facilitates higher-level protocols that inherit DIDComm’s guarantees)</li>
<li><strong>Efficient</strong> (doesn’t waste bandwidth, battery, storage space, or CPU)</li>
</ol>
<h3 id="ramifications"><a class="toc-anchor" href="#ramifications">§</a> Ramifications</h3>
<p>As a list of buzz words, this may elicit nods rather than surprise. However, design tradeoffs are inevitable, and several of these items have noteworthy ramifications.</p>
<h4 id="message-based-asynchronous-and-simplex"><a class="toc-anchor" href="#message-based-asynchronous-and-simplex">§</a> Message-Based, Asynchronous, and Simplex</h4>
<p>The dominant paradigm in mobile and web development today is duplex request-response. You call an API with certain inputs, and you get back a response with certain outputs over the same channel, shortly thereafter. This is the world of <a href="https://swagger.io/docs/specification/about/">OpenAPI (Swagger)</a>, and it has many virtues.</p>
<p>Unfortunately, many agents are not good analogs to web servers. They may be mobile devices that turn off at unpredictable intervals and that lack a stable connection to the network. They may need to work peer-to-peer, when the internet is not available. They may need to interact in time frames of hours or days, not with 30-second timeouts. They may not listen over the same channel that they use to talk.</p>
<p>Because of this, the fundamental paradigm for DIDComm is message-based, asynchronous, and simplex. Agent X sends a message over channel A. Sometime later, it may receive a response from Agent Y over channel B. This is much closer to an email paradigm than a web paradigm.</p>
<p>On top of this foundation, it is possible to build elegant, synchronous request-response interactions. All of us have interacted with a friend who’s emailing or texting us in near-realtime. However, interoperability begins with a least-common-denominator assumption that’s simpler.</p>
<h4 id="message-level-security-reciprocal-authentication"><a class="toc-anchor" href="#message-level-security-reciprocal-authentication">§</a> Message-Level Security, Reciprocal Authentication</h4>
<p>The security and privacy goals, and the asynchronous+simplex design decision, break familiar web assumptions in another way. Servers are commonly run by institutions, and we authenticate them with certificates. People and things are usually authenticated to servers by some sort of login process quite different from certificates, and this authentication is cached in a session object that expires. Furthermore, web security is provided at the transport level (TLS); it is not an independent attribute of the messages themselves.</p>
<p>In a partially disconnected world where a communication channel is not assumed to support duplex request-response, and where the security can’t be ignored as a transport problem, traditional TLS, login, and expiring sessions are impractical. Furthermore, centralized servers and certificate authorities perpetuate a power and UX imbalance between servers and clients that doesn’t fit with the peer-oriented DIDComm.</p>
<p>DIDComm uses public key cryptography, not certificates from some parties and passwords from others. Its security guarantees are independent of the transport over which it flows. It is sessionless (though sessions can <em>easily</em> be built atop it). When authentication is required, all parties do it the same way.</p>
<h3 id="processing-model"><a class="toc-anchor" href="#processing-model">§</a> Processing Model</h3>
<ul>
<li>Message-oriented, with sender and receiver(s)</li>
<li>Encryption Envelope</li>
</ul>
<h2 id="message-types"><a class="toc-anchor" href="#message-types">§</a> Message Types</h2>
<p>This spec discusses messages in three different formats. The casual phrase “DIDComm message” is ambiguous, but usually refers to DIDComm encrypted messages (the outermost box in the diagram below). These will constitute the vast majority of network traffic in most DIDComm deployments, and they are responsible for security guarantees in the system. However, the role of encrypted messages cannot be understood without reference to the simpler formats they contain.</p>
<p><img src="../collateral/didcomm-envelopes.png" alt="DIDComm envelopes"></p>
<h3 id="media-types"><a class="toc-anchor" href="#media-types">§</a> Media Types</h3>
<p>Media types are based on the conventions of <a href="https://tools.ietf.org/html/rfc6838">RFC6838</a>. Similar to <a href="https://tools.ietf.org/html/rfc7515#section-4.1.9">RFC7515</a>, the <code>application/</code> prefix MAY be omitted and the recipient MUST treat media types not containing <code>/</code> as having the <code>application/</code> prefix present.</p>
<h3 id="didcomm-plaintext-messages"><a class="toc-anchor" href="#didcomm-plaintext-messages">§</a> DIDComm Plaintext Messages</h3>
<p>A DIDComm message in its plaintext form, not packaged into any protective envelope, is known as a <strong>DIDComm plaintext message</strong>. Plaintext messages lack confidentiality and integrity guarantees, and are repudiable. They are therefore not normally transported across security boundaries. However, this may be a helpful format to inspect in debuggers, since it exposes underlying semantics, and it is the format used in this spec to give examples of headers and other internals. Depending on ambient security, plaintext may or may not be an appropriate format for DIDComm data at rest.</p>
<p>When higher-level protocols are built atop DIDComm, applications remove the protective envelope(s) and process the plaintext that’s inside. Specs for higher-level protocols typically document message structure and provide examples in this format; protective envelopes are assumed but ignored as a low-level detail.</p>
<p>Applications running one or more DIDComm-based protocols may wish to define their own media types for the protocols they support. Absent such customization, the preferred media type for a generic DIDComm plaintext message SHOULD be <code>application/didcomm-plain+json</code>. This correctly conveys the fact that code handling such content functions at a different level from DIDComm’s security and routing, and that generic JSON tools and actions are likely to be a helpful fallback in processing the content.</p>
<p>DIDComm plaintext messages are also correctly understood as JWM content (see <a href="#plaintext-message-structure">Plaintext Message Structure</a>, below). Thus a media type for JWMs MIGHT be an accurate but more generic way to categorize them. However, not all JWMs are DIDComm messages, so this categorization is suboptimal. Similarly, <code>application/json</code> is true, but overly generic and therefore not recommended.</p>
<p>When persisted as a file or attached as a payload in other contexts, the file extension for DIDComm plaintext messages SHOULD be <code>dcpm</code>, giving a globbing pattern of <code>*.dcpm</code>; this SHOULD be be read as “Star Dot D C P M” or as “D C P M” files. We imagine people will reference this media type by saying, “I am looking at a DIDComm Plaintext Message file”, or “This database record is in DIDComm Plaintext format”, or “Does my editor have a DIDComm Plaintext Message plugin?” A possible icon for this file format depicts green JSON text in a message bubble (<a href="../collateral/dcpm.svg">svg</a> | <a href="../collateral/dcpm-256.png">256x256</a> | <a href="../collateral/dcpm-128.png">128x128</a> | <a href="../collateral/dcpm-64.png">64x64</a>):</p>
<p><img src="../collateral/dcpm-128.png" alt="DIDComm Plaintext Message Icon"></p>
<h3 id="didcomm-signed-message"><a class="toc-anchor" href="#didcomm-signed-message">§</a> DIDComm Signed Message</h3>
<p>A <strong>DIDComm signed message</strong> is a JWS envelope that associates a non-repudiable signature with the plaintext message inside it.</p>
<p>Signed messages are not necessary to provide message integrity (tamper evidence), or to prove the sender to the recipient. Both of these guarantees automatically occur with the authenticated encryption in DIDComm encrypted messages. Signed messages are only necessary when the origin of plaintext must be provable to third parties, or when the sender can’t be proven to the recipient by authenticated encryption because the recipient is not known in advance (e.g., in a broadcast scenario). Adding a signature when one is not needed <a href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0049-repudiation/README.md#summary">can degrade rather than enhance security because it relinquishes the sender’s ability to speak off the record</a>. We therefore expect signed messages to be used in a few cases, but not as a matter of course.</p>
<p>When a message is <em>both</em> signed and encrypted, the plaintext is signed, and then the signed envelope is encrypted. The opposite order is not used, since it would imply that the signer committed to opaque data (which is unsafe and undermines non-repudiation).</p>
<p>The <a href="https://tools.ietf.org/html/rfc6838">media type</a> of a DIDComm signed message SHOULD be <code>application/didcomm-signed+json</code>.</p>
<p>Because a DIDComm signed message is also a JWS, a true but less specific media type MIGHT be <code>application/jose</code>. (Although <code>application/jwt</code> is a registered media type, <code>application/jwe</code> and <code>application/jws</code> <a href="https://tools.ietf.org/html/rfc7516#section-9">are not</a>. This is <a href="https://mailarchive.ietf.org/arch/msg/jose/FRTPwiOLOc5DILfY_QFZyemn9VU/">deliberate</a>.) Using the more generic type is not recommended, as content categorized in this way is unlikely to get the DIDComm-specific handling it needs. Similarly, it is also true but overly generic and therefore not recommended to describe a DIDComm signed message as <code>application/json</code>.</p>
<p>The media type of the envelope MUST be set in the <code>typ</code> <a href="https://tools.ietf.org/html/rfc7515#section-4.1.9">property</a> of the JWS and the media type of the payload MUST be set in the <code>cty</code> <a href="https://tools.ietf.org/html/rfc7515#section-4.1.10">property</a> of the JWS.</p>
<p>When persisted as a file or attached as a payload in other contexts, the file extension for DIDComm signed messages SHOULD be <code>dcsm</code>, giving a globbing pattern of <code>*.dcsm</code>; this SHOULD be be read as “Star Dot D C S M” or as “D C S M” files. A possible icon for this media type depicts a signed envelope (<a href="../collateral/dcsm.svg">svg</a> | <a href="../collateral/dcsm-256.png">256x256</a> | <a href="../collateral/dcsm-128.png">128x128</a> | <a href="../collateral/dcsm-64.png">64x64</a>):</p>
<p><img src="../collateral/dcsm-128.png" alt="DIDComm Signed Message Icon"></p>
<h3 id="didcomm-encrypted-message"><a class="toc-anchor" href="#didcomm-encrypted-message">§</a> DIDComm Encrypted Message</h3>
<p>A <strong>DIDComm encrypted message</strong> hides its content from all but authorized recipients, discloses and proves the sender to exactly and only those recipients, and provides integrity guarantees. It is important in privacy-preserving routing. It is what normally moves over network transports in DIDComm applications, and is the safest format for storing DIDComm data at rest.</p>
<p>The <a href="https://tools.ietf.org/html/rfc6838">media type</a> of a DIDComm encrypted message SHOULD be <code>application/didcomm-encrypted+json</code>.</p>
<blockquote>
<p>Note: If future versions of this spec allow binary encodings, variations like <code>application/didcomm-encrypted+cbor</code> (see <a href="https://tools.ietf.org/html/rfc7049#section-7.5">CBOR RFC 7049, section 7.5</a>), <code>application/didcomm-encrypted+msgpack</code>, or <code>application/didcomm-encrypted+protobuf</code> may become reasonable. Future DIDComm specs that encompass comm patterns other than messaging — DIDComm multicast or DIDComm streaming, for example — might use a suffix: <code>application/didcomm-encrypted-multicast</code> or similar.</p>
</blockquote>
<p>Because a DIDComm encrypted message is also a JWE, a true but less specific media type MIGHT be <code>application/jose</code>. Note how this overlaps with the generic media type of the JWS of a DIDComm Signed Message. As with DIDComm signed Messages, using more generic media types is ambiguous and not recommended.</p>
<p>The media type of the envelope MUST be set in the <code>typ</code> <a href="https://tools.ietf.org/html/rfc7516#section-4.1.11">property</a> of the JWE and the media type of the payload MUST be set in the <code>cty</code> <a href="https://tools.ietf.org/html/rfc7516#section-4.1.12">property</a> of the JWE.</p>
<p>When persisted as a file or attached as a payload in other contexts, the file extension for DIDComm encrypted messages SHOULD be <code>dcem</code>, giving a globbing pattern of <code>*.dcem</code>; this SHOULD be be read as “Star Dot D C E M” or as “D C E M” files. A possible icon for this file format depicts an envelope with binary overlay, protected by a lock (<a href="../collateral/dcem.svg">svg</a> | <a href="../collateral/dcem-256.png">256x256</a> | <a href="../collateral/dcem-128.png">128x128</a> | <a href="../collateral/dcem-64.png">64x64</a>):</p>
<p><img src="../collateral/dcem-128.png" alt="DIDComm Encrypted Message Icon"></p>
<h2 id="negotiating-compatibility"><a class="toc-anchor" href="#negotiating-compatibility">§</a> Negotiating Compatibility</h2>
<p>When parties want to communicate via DIDComm, a number of mechanisms must align. These include:</p>
<ol>
<li>The type of service endpoint used by each party</li>
<li>The key types used for encryption and/or signing</li>
<li>The format of the encryption and/or signing envelopes</li>
<li>The encoding of plaintext messages</li>
<li>The protocol used to forward and route</li>
<li>The protocol embodied in the plaintext messages</li>
</ol>
<p>Although DIDComm allows flexibility in each of these choices, it is not expected that a given DIDComm implementation will support many permutations. Rather, we expect a few sets of choices that commonly go together. We call a set of choices that work well together a <strong>profile</strong>. Profiles are identified by a string that matches the conventions of IANA media types, but they express choices about plaintext, encryption, signing, and routing in a single value. The following profile identifiers are defined in this version of the spec:</p>
<h3 id="defined-profiles"><a class="toc-anchor" href="#defined-profiles">§</a> Defined Profiles</h3>
<ul>
<li><code>didcomm/aip1</code>: The encryption envelope, signing mechanism, plaintext conventions, and routing algorithms embodied in Aries AIP 1.0, circa 2020.</li>
<li><code>didcomm/aip2;env=rfc19</code>: The signing mechanism, plaintext conventions, and routing algorithms embodied in Aries AIP 2.0, circa 2021 – with the old-style encryption envelope from Aries RFC 0019. This legal variant of AIP 2.0 minimizes differences with codebases that shipped AIP 1.0 support.</li>
<li><code>didcomm/aip2;env=rfc587</code>: The signing mechanism, plaintext conventions, and routing algorithms embodied in Aries AIP 2.0, circa 2021 – with the new-style encryption envelope from Aries RFC 0587. This legal variant of AIP 2.0 lays the foundation for DIDComm v2 support by anticipating the eventual envelope change.</li>
<li><code>didcomm/v2</code>: The encryption envelope, signing mechanism, plaintext conventions, and routing algorithms embodied in this spec.</li>
</ul>
<p>Profiles are named in the <code>accept</code> section of a DIDComm service endpoint and in an out-of-band message. When Alice declares that she accepts <code>didcomm/v2</code>, she is making a declaration about more than her own endpoint. She is saying that all publicly visible steps in an inbound route to her will use the <code>didcomm/v2</code> profile, such that a sender only has to use <code>didcomm/v2</code> choices to get the message from Alice’s outermost mediator to Alice’s edge. It is up to Alice to select and configure mediators and internal routing in such a way that this is true for the sender.</p>
<h2 id="plaintext-message-structure"><a class="toc-anchor" href="#plaintext-message-structure">§</a> Plaintext Message Structure</h2>
<p>DIDComm plaintext messages are based on <a href="https://tools.ietf.org/html/draft-looker-jwm-01">JWM (JSON Web Messages)</a>. A message has a basic structure that specifies the message type, id, and other attributes common to all messages. These common attributes appear at the top level of a DIDComm message, and are called headers. A message also includes attributes specific to the message type. Type specific message attributes are contained within the <code>body</code> attribute of a message.</p>
<p>Prior to being sent to a recipient, the JWM is usually encrypted into a JWE according to the JWM spec.</p>
<p>The following example shows common elements of a plaintext message. Further details and advanced usage are covered elsewhere in this spec.</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"&lt;message-type-uri>"</span><span class="token punctuation">,</span>
    <span class="token property">"from"</span><span class="token operator">:</span> <span class="token string">"did:example:alice"</span><span class="token punctuation">,</span>
    <span class="token property">"to"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"did:example:bob"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"created_time"</span><span class="token operator">:</span> <span class="token number">1516269022</span><span class="token punctuation">,</span>
    <span class="token property">"expires_time"</span><span class="token operator">:</span> <span class="token number">1516385931</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    	<span class="token property">"messagespecificattribute"</span><span class="token operator">:</span> <span class="token string">"and its value"</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="message-headers"><a class="toc-anchor" href="#message-headers">§</a> Message Headers</h3>
<p>The predefined attributes of a DIDComm plaintext message at the level of its outer packaging (effectively, the “headers” of the message) are as follows:</p>
<ul>
<li>
<p><strong>id</strong> - REQUIRED. Message ID. The <code>id</code> attribute value MUST be unique to the sender.</p>
</li>
<li>
<p><strong>type</strong> - REQUIRED. Message Type. The <code>type</code> attribute value MUST be a valid <a href="protocols.md#message-type-uri">Message Type URI</a>, that when resolved gives human readable information about the message. The attribute’s value also informs the content of the message, for example the presence of other attributes and how they should be processed.</p>
</li>
<li>
<p><strong>to</strong> - OPTIONAL. Identifier(s) for recipients. MUST be an array of strings where each element is a valid DID or <a href="https://w3c.github.io/did-core/#did-url-syntax">DID URL</a> (without the <a href="https://w3c.github.io/did-core/#fragment">fragment component</a>) that identifies a member of the message’s intended audience.</p>
<p>When Alice sends the same message to Bob and Carol, it is by inspecting this header that Bob and Carol learn that the message was sent to both of them. If the header is omitted, each recipient can only assume they are the only recipient (much like an email sent only to <code>BCC:</code> addresses).</p>
<p>The <code>to</code> header cannot be used for routing, since it is encrypted at every intermediate point in a route. Instead, the <code>forward</code> message contains a <code>next</code> attribute in its body that specifies the target for the next routing operation.</p>
</li>
<li>
<p><strong>from</strong> - OPTIONAL. Sender identifier. The <code>from</code> attribute MUST be a string that is a valid DID or <a href="https://w3c.github.io/did-core/#did-url-syntax">DID URL</a> (without the <a href="https://w3c.github.io/did-core/#fragment">fragment component</a>) which identifies the sender of the message. When a message is encrypted, the sender key MUST be authorized for encryption by this DID. Authorization of the encryption key for this DID MUST be verified by message recipient with the proper proof purposes. See the <a href="#Message-Authentication">message authentication</a> section for additional details.</p>
<p>When the sender wishes to be anonymous, they should use a new DID created for the purpose to avoid correlation with any other behavior or identity. Peer DIDs are lightweight and require no ledger writes, and therefore a good method to use for this purpose.</p>
</li>
<li>
<p><strong>created_time</strong> - OPTIONAL. Message Created Time. The <code>created_time</code> attribute is used for the sender to express when they created the message, expressed in UTC Epoch Seconds (seconds since 1970-01-01T00:00:00Z UTC) [link](1970-01-01T00:00:00Z UTC). This attribute is informative to the recipient, and may be relied on by protocols.</p>
</li>
<li>
<p><strong>expires_time</strong> - OPTIONAL. Message Expired Time. The <code>expires_time</code> attribute is used for the sender to express when they consider the message to be expired, expressed in UTC Epoch Seconds (seconds since 1970-01-01T00:00:00Z UTC) [link](1970-01-01T00:00:00Z UTC). This attribute signals when the message is considered no longer valid by the sender. When omitted, the message is considered to have no expiration by the sender.</p>
</li>
</ul>
<p>In the outer packaging of message metadata, DIDComm follows the extensibility pattern established by the JW* family of standards. (It also emulates the design of message headers in SMTP, request headers in HTTP, and labels on physical pieces of mail.) A modest inventory of predefined “header” fields is specified, as shown above. Additional fields with unreserved names can be added at the discretion of producers and consumers of messages; any software that doesn’t understand such fields should ignore them and MUST NOT fail because of their inclusion in a message. This is appropriate for a simple, flat data model.</p>
<p>Aligning with <a href="https://tools.ietf.org/html/rfc6648.html">RFC 6648</a>, DIDComm explicitly rejects the <code>X-*</code> headers convention that creates divergent pseudo-standards; if a new header needs broad support, it must be standardized properly. Alternatively, a JSON-LD <code>@context</code> header can be added, providing namespacing for fields other than those predefined in the spec. Since we expect header fields to be small in number and modest in complexity, we expect this sort of powerful extensibility to be unnecessary in most cases.</p>
<h4 id="simple-vs-structured"><a class="toc-anchor" href="#simple-vs-structured">§</a> Simple vs. Structured</h4>
<p>Headers can be simple (mapping a header name to an integer or a string) or structured (mapping a header name to JSON substructure – an array or JSON object). When defining a new header type, the following guidelines apply:</p>
<ul>
<li>Headers SHOULD NOT use more structure than necessary; simple headers are preferred.</li>
<li>However, a header value SHOULD NOT require interpretation over and above ordinary JSON parsing. Prefer JSON structure to specialized string DSLs like the one that encodes media type preferences in an HTTP <code>Accept</code> header. (<a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-15">HTTP Structured Headers</a> provide similar functionality but are unnecessary here, since DIDComm plaintext already has an easily parseable syntax.)</li>
<li>Headers that are only meaningful together SHOULD be grouped into a JSON object.</li>
</ul>
<h4 id="relationship-to-json-ld"><a class="toc-anchor" href="#relationship-to-json-ld">§</a> Relationship to JSON-LD</h4>
<p>The problem domain of DIDComm intersects with other aspects of decentralized identity, where JSON-LD plays a role in some standards. Thus it may be natural to wonder about DIDComm’s relationship to JSON-LD and to the rich semantics and extensibility features it offers. The short answer is that DIDComm is not dependent on JSON-LD, but it is compatible with it. We expect these two technologies to remain mostly orthogonal.</p>
<p>The body of a message – everything inside the <code>body</code> object – is different. Here, there is substantial variety and complexity. Structures may be sophisticated graphs, represented with nested objects and arrays. JSON-LD is not required at this level, either. However, it is available, and may be appropriate for certain use cases where extensibility is an important feature. JSON-LD usage, if it occurs, SHOULD be a declared feature of a protocol as a whole, not an ad hoc extension to arbitrary individual messages, and MUST be signalled by the inclusion of a <code>@context</code> inside <code>body</code>. Unless a protocol declares a JSON-LD dependency, the same rules apply to JSON-LD-isms as apply to any other unrecognized structure in a DIDComm message: additional fields can be added to any part of message structure, should be ignored if not understood, and MUST NOT be the basis of failure by recipients.</p>
<h3 id="did-rotation"><a class="toc-anchor" href="#did-rotation">§</a> DID Rotation</h3>
<p>DIDComm is based on DIDs and their associated DID Documents. Changes to keys and endpoints are the concern of each DID method and are utilized but not managed by DIDComm. DID Rotation serves a very specific and narrow need to switch from one DID method to another. This is very common at the beginning of a new DIDComm relationship when a public DID or a temporary DID passed unencrypted is rotated out for a DID chosen for the relationship. As rotation between one DID and another is outside the scope of any DID method, the details of DID Rotation are handled within DIDComm itself.</p>
<p>When a DID is rotated, the new DID is put into immediate use encrypting the message, and one additional attribute is included as a message header:</p>
<ul>
<li><strong>from_prior</strong>: A JWT, with with <code>sub</code>: new DID and <code>iss</code>: prior DID, with a signature from a key authorized by prior DID.</li>
</ul>
<p>When a message is received from an unknown DID, the recipient should check for existence of the <code>from_prior</code> header. The JWT in the<code>from_prior</code> attribute is used to extract the prior DID (<code>iss</code>) and is checked to verify the validity of the rotation. The recipient then associates the message with context related to the known sender. The new DID and associated DID Document information should be used for further communication.</p>
<p>The validity of the DID rotation is verified by checking the JWT signature against the key indicated in the <code>kid</code> header parameter. The indicated key MUST be authorized in the DID Document of the prior DID (<code>iss</code>).</p>
<p>The <code>from_prior</code> attribute should be included in messages sent until the party rotating receives a message sent to the new DID. If multiple messages are received to containing the rotation headers after being processed by the recipient, they may be ignored.</p>
<h4 id="jwt-details"><a class="toc-anchor" href="#jwt-details">§</a> JWT Details</h4>
<p>The JWT is constructed as follows, with appropriate values changed.</p>
<p><strong>Header</strong>:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span><span class="token punctuation">,</span>
  <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"EdDSA"</span><span class="token punctuation">,</span>
  <span class="token property">"crv"</span><span class="token operator">:</span> <span class="token string">"ED25519"</span><span class="token punctuation">,</span>
  <span class="token property">"kid"</span><span class="token operator">:</span> <span class="token string">"&lt;key id authorized in prior DID>"</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Payload</strong>:</p>
<pre class="language-jsonc"><code class="language-jsonc">{
  &quot;sub&quot;: &quot;&lt;new DID URI&gt;&quot;,
  &quot;iss&quot;: &quot;&lt;prior DID URI&gt;&quot;,
  &quot;iat&quot;: 1516239022 //datetime of the rotation, not message
}
</code></pre>
<h4 id="example-message-rotating-did"><a class="toc-anchor" href="#example-message-rotating-did">§</a> Example Message Rotating DID</h4>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"&lt;message-type-uri>"</span><span class="token punctuation">,</span>
    <span class="token property">"from"</span><span class="token operator">:</span> <span class="token string">"did:example:alice2"</span><span class="token punctuation">,</span>
    <span class="token property">"from_prior"</span><span class="token operator">:</span> <span class="token string">"&lt;JWT with sub:did:example:alice2 and iss:did:example:alice>"</span><span class="token punctuation">,</span>
    <span class="token property">"to"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"did:example:bob"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"created_time"</span><span class="token operator">:</span> <span class="token number">1516269022</span><span class="token punctuation">,</span>
    <span class="token property">"expires_time"</span><span class="token operator">:</span> <span class="token number">1516385931</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    	<span class="token property">"messagespecificattribute"</span><span class="token operator">:</span> <span class="token string">"and its value"</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h4 id="rotation-limitations"><a class="toc-anchor" href="#rotation-limitations">§</a> Rotation Limitations</h4>
<ul>
<li>This rotation method does not cover cases where a multi-sig is required. Rotations with such requirements should use a more expressive protocol.</li>
<li>This rotation method only supports the case where a new DID is used, replacing an old DID which is no longer used. Adjustments to DIDs used between different parties that does not fit this narrow use should use a more expressive protocol.</li>
</ul>
<h1 id="message-encryption"><a class="toc-anchor" href="#message-encryption">§</a> Message Encryption</h1>
<p>DIDComm supports two types of message encryption: Authenticated Sender Encryption and Anonymous Sender Encryption. Both forms are encrypted to the recipient, but only Authenticated Sender Encryption provides assurances of who the sender is.</p>
<p>The encrypted form of a JWM is a JWE. The JOSE family defines <a href="https://tools.ietf.org/html/rfc7518">JSON Web Algorithms</a> (JWAs) which standardize certain cryptographic operations that are related to preparing JOSE structures. For the purposes of interoperability, DIDComm messaging does not support all JWAs, rather it takes a subset of the supported algorithms that are applicable for the following cases around secure messaging. These supported algorithms are listed here.</p>
<h2 id="sender-authenticated-encryption"><a class="toc-anchor" href="#sender-authenticated-encryption">§</a> Sender Authenticated Encryption</h2>
<p>For an encrypted DIDComm Message, the JWA of <code>ECDH-1PU</code> defined by <a href="https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-04">draft</a> MUST be used within the structure of a JWE.</p>
<h2 id="anonymous-encryption"><a class="toc-anchor" href="#anonymous-encryption">§</a> Anonymous Encryption</h2>
<p>When a sender would like to encrypt a message for a recipient or multiple recipients but not be authenticated by the recipients as the party who encrypted the message, the JWA of <code>ECDH-ES</code> defined by <a href="https://tools.ietf.org/html/rfc7518#section-4.6">RFC 7518</a> SHOULD be used within the structure of a JWE.</p>
<p>Anonymous Encryption removes authenticated encryption, a significant benefit of the DIDComm specification. Use of Anonymous Encryption SHOULD NOT be paired with a method of message authentication other than Authenticated Encryption as defined in this specification. Further discussion of message authentication can be found in the Implementation Guide.</p>
<h2 id="curves-and-content-encryption-algorithms"><a class="toc-anchor" href="#curves-and-content-encryption-algorithms">§</a> Curves and Content Encryption Algorithms</h2>
<p>For the keys involved in key agreement, the following elliptic curves MUST be supported.</p>
<table>
<thead>
<tr>
<th>Curve</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>X25519</td>
<td>The underlying curve is actually <code>Curve25519</code>, however when used in the context of Diffie-Hellman the identifier of <code>X25519</code> is used</td>
</tr>
<tr>
<td>P-384</td>
<td>NIST defined P-384 elliptic curve</td>
</tr>
<tr>
<td>P-256</td>
<td>NIST defined P-256 elliptic curve - deprecated in favor of P-384</td>
</tr>
</tbody>
</table>
<p>For content encryption of the message, the following algorithms MUST be supported.</p>
<table>
<thead>
<tr>
<th>Algorithm(JWA)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>XC20P</td>
<td>XChaCha20Poly1305</td>
</tr>
<tr>
<td>A256GCM</td>
<td>AES-GCM with a 256 bit key</td>
</tr>
</tbody>
</table>
<p>TODO: Include language about safe nonce considerations.</p>
<h2 id="key-wrapping-algorithms"><a class="toc-anchor" href="#key-wrapping-algorithms">§</a> Key Wrapping Algorithms</h2>
<table>
<thead>
<tr>
<th>KW Algorithm</th>
<th>Curve (epk crv)</th>
<th>key type (epk kty)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ECDH-ES+A256KW</td>
<td>P-256</td>
<td>EC</td>
<td>ECDH-ES key wrapping using key with NIST defined P-256 elliptic curve to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/rfc7518#section-4.6.2">7518</a></td>
</tr>
<tr>
<td>ECDH-ES+A256KW</td>
<td>P-384</td>
<td>EC</td>
<td>ECDH-ES key wrapping using key with NIST defined P-384 elliptic curve to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/rfc7518#section-4.6.2">7518</a></td>
</tr>
<tr>
<td>ECDH-ES+A256KW</td>
<td>P-521</td>
<td>EC</td>
<td>ECDH-ES key wrapping using key with NIST defined P-521 elliptic curve to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/rfc7518#section-4.6.2">7518</a></td>
</tr>
<tr>
<td>ECDH-ES+A256KW</td>
<td>X25519</td>
<td>OKP</td>
<td>ECDH-ES with X25519 (<a href="https://tools.ietf.org/html/rfc7748#section-5">RFC7748 section 5</a>) to create a 256 bits key. The underlying curve is actually <code>Curve25519</code>, however when used in the context of Diffie-Hellman the identifier of <code>X25519</code> is used</td>
</tr>
<tr>
<td>ECDH-1PU+A256KW</td>
<td>P-256</td>
<td>EC</td>
<td>ECDH-1PU key wrapping using key with NIST defined P-256 elliptic curve to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-04#section-2">ecdh-1pu</a></td>
</tr>
<tr>
<td>ECDH-1PU+A256KW</td>
<td>P-384</td>
<td>EC</td>
<td>ECDH-1PU key wrapping using key with NIST defined P-384 elliptic curve to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-04#section-2">ecdh-1pu</a></td>
</tr>
<tr>
<td>ECDH-1PU+A256KW</td>
<td>P-521</td>
<td>EC</td>
<td>ECDH-1PU key wrapping using key with NIST defined P-521 elliptic curve to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-04#section-2">ecdh-1pu</a></td>
</tr>
<tr>
<td>ECDH-1PU+A256KW</td>
<td>X25519</td>
<td>OKP</td>
<td>ECDH-1PU X25519 (<a href="https://tools.ietf.org/html/rfc7748#section-5">RFC7748 section 5</a>) to create a 256 bits key as defined in <a href="https://tools.ietf.org/html/draft-madden-jose-ecdh-1pu-04#section-2">ecdh-1pu</a></td>
</tr>
</tbody>
</table>
<h2 id="media-types-2"><a class="toc-anchor" href="#media-types-2">§</a> Media Types</h2>
<p>The media type of the envelope MUST be set in the <code>typ</code> <a href="https://tools.ietf.org/html/rfc7516#section-4.1.11">property</a> of the JWE and the media type of the payload MUST be set in the <code>cty</code> <a href="https://tools.ietf.org/html/rfc7516#section-4.1.12">property</a> of the JWE. The <a href="#message-types">message types</a> section provides general discussion of the media types.</p>
<p>For example, following the guidelines of <a href="#message-types">message types</a>, an encrypted envelope with a plaintext DIDComm payload contains the <code>typ</code> property with the value <code>application/didcomm-encrypted+json</code> and <code>cty</code> property with the value <code>application/didcomm-plain+json</code>.</p>
<h2 id="perfect-forward-secrecy"><a class="toc-anchor" href="#perfect-forward-secrecy">§</a> Perfect Forward Secrecy</h2>
<p>Due to the triple Key Derivation algorithm used in ECDH-1PU, all messages sent via DIDComm have weak perfect forward secrecy without any additional security added by the transport layer. In ECDH-1PU this is achieved by encrypting the content encryption key with the output of the hash of the Ze (ECDH of ephemeral key and recipient static key) and Zs (ECDH of static sender key and recipient static key). With Ze bringing the changed derived secret in each message and Zs bringing the repudiable authenticity of each message, the resulting Z (hash of Ze and Zs) carries the properties of weak perfect forward secrecy and repudiable authenticity for each message as well.</p>
<h2 id="key-ids-kid-and-skid-headers-references-in-the-did-document"><a class="toc-anchor" href="#key-ids-kid-and-skid-headers-references-in-the-did-document">§</a> Key IDs <code>kid</code> and <code>skid</code> headers references in the DID document</h2>
<p>Keys used by DIDComm envelopes MUST be sourced from the DIDs exchanged between two agents. Specifically, both sender and recipients keys MUST be retrieved from the DID document’s <code>KeyAgreement</code> verification section as per the <a href="https://identity.foundation/didcomm-messaging/spec/#did-document-keys">DID Document Keys</a> definition.</p>
<p>When Alice is preparing an envelope intended for Bob, the packing process should use a key from both hers and Bob’s DID document’s <code>KeyAgreement</code> section.</p>
<p>Assuming Alice has a DID Doc with the following <code>KeyAgreement</code> definition (source: <a href="https://www.w3.org/TR/did-core/#example-17-key-agreement-property-containing-two-verification-methods">DID V1 Example 17</a>):</p>
<pre class="language-jsonc"><code class="language-jsonc">{
  &quot;@context&quot;: &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;id&quot;: &quot;did:example:123456789abcdefghi&quot;,
  ...
  &quot;keyAgreement&quot;: [
    // this method can be used to perform key agreement as did:...fghi
    &quot;did:example:123456789abcdefghi#keys-1&quot;,
    // this method is *only* approved for key agreement usage, it will not
    // be used for any other verification relationship, so its full description is
    // embedded here rather than using only a reference
    {
      &quot;id&quot;: &quot;did:example:123#zC9ByQ8aJs8vrNXyDhPHHNNMSHPcaSgNpjjsBYpMMjsTdS&quot;,
      &quot;type&quot;: &quot;X25519KeyAgreementKey2019&quot;, // external (property value)
      &quot;controller&quot;: &quot;did:example:123&quot;,
      &quot;publicKeyBase58&quot;: &quot;9hFgmPVfmBZwRvFEyniQDBkz9LmV7gDEqytWyGZLmDXE&quot;
    }
  ],
  ...
}
</code></pre>
<p>The envelope packing process MUST set the <code>skid</code> header with value <code>did:example:123456789abcdefghi#keys-1</code> in the envelope’s protected headers and fetch the underlying key to execute ECDH-1PU key derivation for content key wrapping.</p>
<p>Assuming she also has Bob’s DID document which happens to include the following <code>KeyAgreement</code> section:</p>
<pre class="language-jsonc"><code class="language-jsonc">{
  &quot;@context&quot;: &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;id&quot;: &quot;did:example:jklmnopqrstuvwxyz1&quot;,
  ...
  &quot;keyAgreement&quot;: [
    {
      &quot;id&quot;: &quot;did:example:jklmnopqrstuvwxyz1#key-1&quot;,
      &quot;type&quot;: &quot;X25519KeyAgreementKey2019&quot;, // external (property value)
      &quot;controller&quot;: &quot;did:example:jklmnopqrstuvwxyz1&quot;,
      &quot;publicKeyBase58&quot;: &quot;9hFgmPVfmBZwRvFEyniQDBkz9LmV7gDEqytWyGZLmDXE&quot;
    }
  ],
  ...
}
</code></pre>
<p>There should be only 1 entry in the recipients of the envelope, representing Bob. The corresponding <code>kid</code> header for this recipient MUST have <code>did:example:jklmnopqrstuvwxyz1#key-1</code> as value. The packing process MUST extract the public key bytes found in <code>publicKeyBase58</code> of Bob’s DID Doc <code>KeyAgreement[0]</code> to execute the ECDH-1PU key derivation for content key wrapping.</p>
<p>When Bob receives the envelope, the unpacking process on his end MUST resolve the <code>skid</code> protected header value using Alice’s DID doc’s <code>KeyAgreement[0]</code> in order to extract her public key. In Alice’s DID Doc example above, <code>KeyAgreement[0]</code> is a reference id, it MUST be resolved from the main <code>VerificationMethod[]</code> of Alice’s DID document (not shown in the example).</p>
<p>Once resolved, the unpacker will then execute ECDH-1PU key derivation using this key and Bob’s own recipient key found in the envelope’s <code>recipients[0]</code> to unwrap the content encryption key.</p>
<h2 id="protecting-the-skid-header"><a class="toc-anchor" href="#protecting-the-skid-header">§</a> Protecting the <code>skid</code> header</h2>
<p>When the <code>skid</code> cannot be revealed in a plain-text JWE header (to avoid potentially leaking sender’s key id), the <code>skid</code> MAY be encrypted for each recipient. In this case, instead of having a <code>skid</code> protected header in the envelope, each recipient MAY include an <code>encrypted_skid</code> header with a value based on the encryption of <code>skid</code> using ECDH-ES <code>Z</code> computation of the <code>epk</code> and the recipient’s key as the encryption key.</p>
<p>For applications that don’t require this protection, they MAY use <code>skid</code> protected header directly without any additional recipient headers.</p>
<p>Applications MUST use either <code>skid</code> protected header or <code>encrypted_skid</code> recipients header but not both in the same envelope.</p>
<h2 id="examples"><a class="toc-anchor" href="#examples">§</a> Examples</h2>
<p>While the details of encrypting a JWM into a JWE are included in the <a href="https://tools.ietf.org/html/draft-looker-jwm-01">JWM spec</a>, a few examples are included here for clarity.</p>
<p>TODO: Add examples here</p>
<h2 id="message-signing"><a class="toc-anchor" href="#message-signing">§</a> Message Signing</h2>
<p>A DIDComm message can be signed, either in conjunction with encryption or independently if the message will remain unencrypted.</p>
<p>If a message is signed and encrypted to add non-repudiation, it must be signed prior to encryption. This is known as a <a href="https://tools.ietf.org/html/draft-looker-jwm-01#section-1.2">nested JWM</a>.</p>
<h3 id="algorithms"><a class="toc-anchor" href="#algorithms">§</a> Algorithms</h3>
<p>When a sender would like for a message to feature a non-repudiable digital signature the JWA’s defined below can be used within the structure of a JWS.</p>
<p>For digital signatures the following algorithms MUST be verifiable. At least one of the following curves MUST be supported for creating digital signatures.</p>
<table>
<thead>
<tr>
<th>Algorithm(JWA)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>EdDSA (with crv=Ed25519)</td>
<td>Elliptic curve digital signature with edwards curves and SHA-512</td>
</tr>
<tr>
<td>ES256</td>
<td>Elliptic curve digital signature with NIST p-256 curve and SHA-256</td>
</tr>
<tr>
<td>ES256K</td>
<td>Elliptic curve digital signature with Secp256k1 keys.</td>
</tr>
</tbody>
</table>
<h3 id="construction"><a class="toc-anchor" href="#construction">§</a> Construction</h3>
<p>Construct a JWS with the following header:</p>
<pre class="language-json"><code class="language-json">   <span class="token punctuation">{</span><span class="token property">"typ"</span><span class="token operator">:</span><span class="token string">"JWM"</span><span class="token punctuation">,</span>
    <span class="token property">"kid"</span><span class="token operator">:</span><span class="token string">"Ef1sFuyOozYm3CEY4iCdwqxiSyXZ5Br-eUDdQXk6jaQ"</span><span class="token punctuation">,</span>
    <span class="token property">"alg"</span><span class="token operator">:</span><span class="token string">"ES256"</span><span class="token punctuation">}</span>
</code></pre>
<p>The JWS payload is the Base64url encoded JWM.</p>
<p>When transmitted in a normal JWM fashion, the JSON Serialization MUST be used.</p>
<h3 id="verification"><a class="toc-anchor" href="#verification">§</a> Verification</h3>
<p>When verifying the signature, an additional check must be performed after verifying the JWS. The key used in the signature must be authorized to do so in the Document resolved from the DID in the <code>from</code> attribute. If the key is not authorized for the signature, the signature is invalid.</p>
<h3 id="application"><a class="toc-anchor" href="#application">§</a> Application</h3>
<h4 id="non-repudiation"><a class="toc-anchor" href="#non-repudiation">§</a> Non-Repudiation</h4>
<p>DIDComm Encrypted messages are repudiable. If non-repudiation is required for a particular protocol message, the message MUST be signed before encryption.</p>
<h4 id="tamper-resistant-oob-messages"><a class="toc-anchor" href="#tamper-resistant-oob-messages">§</a> Tamper Resistant OOB Messages</h4>
<p>Out of Band Messages may be signed to provide tamper resistance.</p>
<h4 id="did-anchoring"><a class="toc-anchor" href="#did-anchoring">§</a> DID Anchoring</h4>
<p>Signing can allow DIDs to be anchored via keys not usable for encrypting DIDComm messages.</p>
<h3 id="examples-2"><a class="toc-anchor" href="#examples-2">§</a> Examples</h3>
<p>TODO: Add examples here</p>
<h2 id="routing"><a class="toc-anchor" href="#routing">§</a> Routing</h2>
<h3 id="routing-protocol"><a class="toc-anchor" href="#routing-protocol">§</a> Routing Protocol</h3>
<h4 id="name-and-version"><a class="toc-anchor" href="#name-and-version">§</a> Name and Version</h4>
<p>The name of this protocol is “Routing Protocol”, and its <a href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/semver.md">version</a> is “2.0”. It is uniquely identified by the <a href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/uris.md#piuri">PIURI</a>:</p>
<pre><code>https://didcomm.org/routing/2.0
</code></pre>
<h4 id="roles"><a class="toc-anchor" href="#roles">§</a> Roles</h4>
<p>There are 3 roles in the protocol: <code>sender</code>, <code>mediator</code>, and <code>recipient</code>. The sender emits messages of type <code>forward</code> to the <code>mediator</code>. The mediator unpacks (decrypts) the payload of an encrypted <code>forward</code> message and passes on the result (an opaque blob that probably contains a differently encrypted payload) to the <code>recipient</code>.</p>
<p><img src="../collateral/routing-roles.png" alt="ordinary sequence"></p>
<blockquote>
<p>Note: the protocol is one-way; the return route for communication might not exist at all, or if it did, it could invert the roles of sender and receiver and use the same mediator, or it could use one or more different mediators, or it could use no mediator at all. This is a separate concern partly specified by the service endpoints in the DID docs of the sender and receiver, and partly explored in <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0092-transport-return-route/README.md">RFC 0092: Transports Return Route</a>.</p>
</blockquote>
<blockquote>
<p>Note: When the mediator is the routing agent of a single identity subject like Alice, the logical receiver is Alice herself, but the physical receiver may manifest as multiple edge devices (a phone, a laptop, a tablet). From the perspective of this protocol, multiplexing the send from mediator to receiver is out of scope for interoperability–compatible and fully supported, but not required or specified in any way.</p>
</blockquote>
<p>In this protocol, the sender and the receiver never interact directly; they only interact via the mediator.</p>
<p>The sender can decorate the <code>forward</code> message in standard DIDComm ways: using <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0032-message-timing/README.md#tutorial"><code>~timing.expires_time</code>, <code>~timing.delay_milli</code> and <code>~timing.wait_until_time</code></a> to introduce timeouts and delays, and so forth. However, the mediator is NOT required to support or implement any of these mixin semantics; only the core forwarding behavior is indispensable. If a mediator sees a decorator that requests behavior it doesn’t support, it MAY return a <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0035-report-problem/README.md"><code>problem-report</code></a> to the sender identifying the unsupported feature, but it is not required to do so, any more than other recipients of DIDComm messages would be required to complain about unsupported decorators in messages they receive.</p>
<blockquote>
<p>[[TODO: needs revision when we decide how ACKs will work and whether explicit requests for an ACK will be conveyed via headers.]] One particular decorator is worth special mention here: <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0015-acks/README.md#requesting-an-ack-please_ack"><code>~please_ack</code></a>. This decorator is intended to be processed by ultimate recipients, not mediators. If it were used with <code>forward</code> messages, it would impose a burden of backward-facing communication that mediators should not have. Furthermore, it could probe a delivery chain in a way that risks privacy for the receiver. Therefore, senders SHOULD NOT use this on <code>forward</code> messages, and mediators SHOULD NOT honor it if present. If a sender wishes to troubleshoot, the <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0034-message-tracing/README.md">message tracing</a> mechanism is recommended.</p>
</blockquote>
<h4 id="states"><a class="toc-anchor" href="#states">§</a> States</h4>
<p>Since data flow is normally one-way, and since the scope of the protocol is a single message delivery, a simplistic way to understand it might be as two instances of the stateless <a href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/notification.png">notification pattern</a>, unfolding in sequence.</p>
<p>However, this doesn’t quite work on close inspection, because the mediator is at least potentially stateful with respect to any particular message; it needs to be if it wants to implement delayed delivery or retry logic. (Or, as noted earlier, the possibility of sending to multiple physical receivers. Mediators are not required to implement any of these features, but the state machine needs to account for their possibility.) Plus, the notification terminology obscures the sender and receiver roles. So we use the following formalization:</p>
<p><img src="../collateral/routing-state-machines.png" alt="">]
Src: <a href="https://docs.google.com/spreadsheets/d/1zxm3cPZ1UDQPDpYJjGmg_qY8451WMk105HBSARJkvDI/edit#gid=0">state machine diagram on gdocs</a></p>
<h4 id="messages"><a class="toc-anchor" href="#messages">§</a> Messages</h4>
<p>The only message in this protocol is the <code>forward</code> message. A simple and common version of a <code>forward</code> message might look like this:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/routing/2.0/forward"</span><span class="token punctuation">,</span>
    <span class="token property">"to"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"did:example:mediator"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"expires_time"</span><span class="token operator">:</span> <span class="token number">1516385931</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token property">"next"</span><span class="token operator">:</span> <span class="token string">"did:foo:1234abcd"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"attachments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token comment">// One payload?</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li><strong>next</strong> - REQUIRED. The DID of the party to send the attached message to.</li>
<li><strong>attachments</strong> - REQUIRED. The encrypted message to send to the party indicated in the <code>next</code> body attribute.</li>
</ul>
<p>When the internal message expires, it’s a good idea to also include an expiration for forward message requests. Include the <code>expires_time</code> header with the appropriate value.</p>
<p>[TODO: describe use of the <code>attn</code> field, and explain why it’s an important construct that allows us to encrypt to all (cryptographic route) but deliver just to the agent most likely to be interested (network route).</p>
<p>[TODO: further revise the following paragraph to clarify that either a key or a DID might be used. Each possibility makes certain tradeoffs, and may be appropriate in certain cases. Keys may be fragile in the face of rotation, and they require a lot of knowledge/maintenance cost for the external mediator. However, DID key references and DIDs may introduce some complications in how the recipient proves control of a DID (a requirement for security, but also a privacy eroder).]</p>
<p>For most external mediators, the value of the <code>next</code> field is likely to be a DID, not a key. However… (see previous TODO note). This hides details about the internals of a sovereign domain from external parties. The sender will have had to multiplex encrypt for all relevant recipient keys, but doesn’t need to know how routing happens to those keys. The mediator and the receiver may have coordinated about how distribution to individual keys takes place (see <a href="https://github.com/hyperledger/aries-rfcs/blob/master/features/0211-route-coordination/README.md">RFC 0211: Route Coordination</a>), but that is outside the scope of concerns of this protocol.</p>
<p>The attachment(s) in the <code>attachments</code> field are able to use the full power of DIDComm attachments, including features like instructing the receiver to download the payload content from a CDN.</p>
<h4 id="rewrapping"><a class="toc-anchor" href="#rewrapping">§</a> Rewrapping</h4>
<p>Normally, the payload attached to the <code>forward</code> message received by the mediator is transmitted directly to the receiver with no further packaging. However, optionally, the mediator can attach the opaque payload to a new <code>forward</code> message, which then acts as a fresh outer envelope for the second half of the delivery. This <a href="#rewrapping">rewrapping</a> means that the “onion” of packed messages stays the same size rather than getting smaller as a result of the forward operation:</p>
<p><img src="../collateral/routing-roles-2.png" alt="re-wrapped sequence"></p>
<p>Rewrapping mode is invisible to senders, but mediators need to know about it, since they change their behavior as a result. Receivers also need to know about it, because it causes them to receive a double-packaged message instead of a singly-packaged one. The outer envelope is a <code>forward</code> message where <code>to</code> is the receiver itself.</p>
<p>Why is such indirection useful?</p>
<ul>
<li>It lets the mediator decorate messages with its own timing and tracing mixins, which may aid troubleshooting. (This would otherwise be impossible, since the inner payload is an opaque blob that almost certainly tamper-evident and encrypted.)</li>
<li>It lets the mediator remain uncommitted to whether the next receiver is another mediator or not. This may provide flexibility in some routing scenarios.</li>
<li>It lets the mediator change the size of the message by adding or subtracting noise from the content.</li>
<li>It allows for dynamic routing late in the delivery chain.</li>
</ul>
<p>These last two characteristics are the foundation of mix networking feature for DIDComm. That feature is the subject of a different RFC; here we only note the existence of the optional feature.</p>
<h3 id="sender-forward-process"><a class="toc-anchor" href="#sender-forward-process">§</a> Sender Forward Process</h3>
<ol>
<li>Sender Constructs Message.</li>
<li>Sender Encrypts Message to recipient(s).</li>
<li>Wrap Encrypted Message in Forward Message for each Routing Key.</li>
<li>Transmit to <code>serviceEndpoint</code> in the manner specified in the [transports] section.</li>
</ol>
<h3 id="mediator-process"><a class="toc-anchor" href="#mediator-process">§</a> Mediator Process</h3>
<p><em>Prior to using a Mediator, it is the recipient’s responsibility to coordinate with the mediator. Part of this coordination informs them of the <code>next</code> address(es) expected, the endpoint, and any Routing Keys to be used when forwarding messages. That coordination is out of the scope of this spec.</em></p>
<ol>
<li>Receives Forward Message.</li>
<li>Retrieves Service Endpoint pre-configured by recipient (<code>next</code> attribute).</li>
<li>Transmit <code>payload</code> message to Service Endpoint in the manner specified in the [transports] section.</li>
</ol>
<p>The recipient (<code>next</code> attribute of Forward Message) may have pre-configured additional routing keys with the mediator that were not present in the DID Document and therefore unknown to the original sender. If this is the case, the mediator should wrap the attached <code>payload</code> message into an additional Forward message once per routing key. This step is performed between (2) and (3).</p>
<h3 id="did-document-keys"><a class="toc-anchor" href="#did-document-keys">§</a> DID Document Keys</h3>
<p>All keys declared in the DID Document’s <code>keyAgreement</code> section should be used as recipients when encrypting a message. The details of key representation are described in the <a href="https://www.w3.org/TR/did-core/#public-keys">Public Keys section of the DID Core Spec</a>.</p>
<p>Keys used in a signed JWM are declared in the DID Document’s <code>authentication</code> section.</p>
<p>TODO: include details about how DIDComm keys are represented/identified in the DID Document. The DID Core Spec appears light on details and examples of <code>keyAgreement</code> keys. Clarifying language should be included here or there.</p>
<h3 id="did-document-service-endpoint"><a class="toc-anchor" href="#did-document-service-endpoint">§</a> DID Document Service Endpoint</h3>
<p>DIDComm DID Document endpoints have the following format:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"did:example:123456789abcdefghi#didcomm-1"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"DIDCommMessaging"</span><span class="token punctuation">,</span>
    <span class="token property">"serviceEndpoint"</span><span class="token operator">:</span> <span class="token string">"http://example.com/path"</span><span class="token punctuation">,</span>
    <span class="token property">"accept"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
       <span class="token string">"didcomm/v2"</span><span class="token punctuation">,</span>
       <span class="token string">"didcomm/aip2;env=rfc587"</span>
     <span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token property">"routingKeys"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"did:example:somemediator#somekey"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>id</strong>: must be unique, as required in <a href="https://www.w3.org/TR/did-core/#service-endpoints">DID Core</a>. No special meaning should be inferred from the <code>id</code> chosen.</p>
<p><strong>type</strong>: MUST be <code>DIDCommMessaging</code>.</p>
<p><strong>serviceEndpoint</strong>: MUST contain a URI for a transport specified in the [transports] section of this spec, or a URI from Alternative Endpoints. It MAY be desirable to constraint endpoints from the [transports] section so that they are used only for the reception of DIDComm messages. This can be particularly helpful in cases where auto-detecting message types is inefficient or undesirable.</p>
<p><strong>accept</strong>*: An optional array of media types in the order of preference for sending a message to the endpoint.
If <code>accept</code> is not specified, the sender uses its preferred choice for sending a message to the endpoint.
Please see <a href="#message-types">Message Types</a> for details about media types.</p>
<p><strong>routingKeys</strong>: An optional ordered array of strings referencing keys to be used when preparing the message for transmission as specified in the [Routing] section of this spec.</p>
<h4 id="multiple-endpoints"><a class="toc-anchor" href="#multiple-endpoints">§</a> Multiple Endpoints</h4>
<p>A DID Document may contain multiple service entries of type <code>DIDCommMessaging</code>. Entries are SHOULD be specified in order of receiver preference, but any endpoint MAY be selected by the sender, typically by protocol availability or preference.</p>
<h4 id="alternative-endpoints"><a class="toc-anchor" href="#alternative-endpoints">§</a> Alternative Endpoints</h4>
<p>In addition to the URIs for [transports], some alternative forms are available.</p>
<h5 id="did"><a class="toc-anchor" href="#did">§</a> DID</h5>
<p>Using a DID for the <code>serviceEndpoint</code> is useful when using a mediator. The DID should be resolved, and services with type of “DIDComm” will contain valid <code>serviceEndpoints</code>. The keyAgreement keys of that DID Document should be appended at the end of the routingKeys section from the message recipient’s DID Document as per the process in [Sender Forward Process]. The key advantage with this approach is that a mediator can rotate keys and update serviceEndpoints without any updates needed to dependent recipients` DID Documents.</p>
<p>A DID representing a mediator SHOULD NOT use alternative endpoints in it’s own DID Document to avoid recursive endpoint resolution. Using only the URIs described in [transports] will prevent such recursion.</p>
<p>Example 1: Mediator</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"did:example:123456789abcdefghi#didcomm-1"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"DIDCommMessaging"</span><span class="token punctuation">,</span>
    <span class="token property">"serviceEndpoint"</span><span class="token operator">:</span> <span class="token string">"did:example:somemediator"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The message is encrypted to the recipient, then wrapped in a forward message encrypted to the keyAgreement keys within the <code>did:example:somemediator</code> DID Document, and transmitted to the URIs present in the <code>did:example:somemediator</code> DID Document with type <code>DIDCommMessaging</code>.</p>
<p>Example 2: Mediator + Routing Keys</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"did:example:123456789abcdefghi#didcomm-1"</span><span class="token punctuation">,</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"DIDCommMessaging"</span><span class="token punctuation">,</span>
    <span class="token property">"serviceEndpoint"</span><span class="token operator">:</span> <span class="token string">"did:example:somemediator"</span><span class="token punctuation">,</span>
    <span class="token property">"routingKeys"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"did:example:anothermediator#somekey"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The message is encrypted to the recipient, then wrapped in a forward message encrypted to <code>did:example:anothermediator#somekey</code>. That forward message is wrapped in a forward message encrypted to keyAgreement keys within the <code>did:example:somemediator</code> DID Document, and transmitted to the URIs present in the <code>did:example:somemediator</code> DID Document with type <code>DIDComm</code>.</p>
<h2 id="transports"><a class="toc-anchor" href="#transports">§</a> Transports</h2>
<h3 id="summary"><a class="toc-anchor" href="#summary">§</a> Summary</h3>
<p>DIDComm Messaging is designed to be transport independent, including message encryption and agent message format. The encryption envelope provides both encryption and authentication, providing trust as a feature of each message. Each transport does have unique features, and we need to standardize how the transport features are (or are not) applied.</p>
<h3 id="delivery"><a class="toc-anchor" href="#delivery">§</a> Delivery</h3>
<p>DIDComm Transports serve only as message <em>delivery</em>. No information about the effects or results from a message is transmitted over the same connection.</p>
<h3 id="reference"><a class="toc-anchor" href="#reference">§</a> Reference</h3>
<h4 id="https"><a class="toc-anchor" href="#https">§</a> HTTP(S)</h4>
<p>HTTP(S) transports are an effective way to send a message to another online agent.</p>
<ul>
<li>Messages are transported via HTTP POST.</li>
<li>The MIME Type for the POST request is <code>application/didcomm-encrypted+json</code>. See <a href="#message-types">Message Types</a> for a general discussion of mime types.</li>
<li>A successful message receipt MUST return a code in the 2xx HTTP Status Code range. It is recommended that a HTTP POST should return a 202 Accepted status code.</li>
<li>POST requests are transmit only. Messages are only sent from the code that submitted the POST request.</li>
<li>HTTP Redirects SHOULD be followed. Only Temporary Redirects (307) are acceptable. Permanent endpoint relocation should be managed with a DID Document update.</li>
<li>Using HTTPS with TLS 1.2 or greater with a forward secret cipher will provide Perfect Forward Secrecy (PFS) on the transmission leg.</li>
</ul>
<h4 id="websocket"><a class="toc-anchor" href="#websocket">§</a> WebSocket</h4>
<p>Websockets are an efficient way to transmit multiple messages without the overhead of individual requests. This is useful in a high bandwidth situation</p>
<ul>
<li>Each message is transmitted individually in an Encryption Envelope.</li>
<li>Each message is sent as single text based message over the websocket.</li>
<li>The trust of each message comes from the Encryption Envelope, not the socket connection itself.</li>
<li>Websockets are considered transmit only. Messages flow only from the agent that opened the socket.</li>
<li>Using Secure Websockets (wss://) with TLS 1.2 or greater with a forward secret cipher will provide Perfect Forward Secrecy (PFS) on the transmission leg.</li>
</ul>
<p>With STOMP over WebSocket, the content-type header is application/didcomm-enc-env as in the HTTP(S) message.</p>
<p>TODO:</p>
<ul>
<li>Quic</li>
<li>Transport binding</li>
</ul>
<h2 id="advanced-message-passing"><a class="toc-anchor" href="#advanced-message-passing">§</a> Advanced Message Passing</h2>
<p>TODO:</p>
<ul>
<li>Deep linking</li>
<li>CHAPI</li>
<li>NFC</li>
<li>Wifi-Direct</li>
<li>Bluetooth</li>
<li>Sneakernet / file oriented / mimetypes</li>
</ul>
<h4 id="embedded-messages"><a class="toc-anchor" href="#embedded-messages">§</a> Embedded Messages</h4>
<p>DIDComm messages may be passed within other messages are protocols when the outer message is passed in a secure way. When messages are passed in this way, they may be passed either as an encrypted message or in plain text. When in plain text format, messages should be represented in json format.</p>
<h5 id="privacy-considerations"><a class="toc-anchor" href="#privacy-considerations">§</a> Privacy Considerations</h5>
<p>When messages are passed in plain text, the privacy and security of the message is subject to the properties of the protocol and transport moving the messages. Extreme care must be taken to protect the message.</p>
<h3 id="connections"><a class="toc-anchor" href="#connections">§</a> Connections</h3>
<p>A Connection is the practical application of a relationship in DID Communication. Having a connection means that each party in the relationship has a DID for the other parties, and parties can communicate securely using the keys and endpoints within each DID Document.</p>
<p>In order to establish a new connection, Simply exchange a new message between parties. Knowing the DID of the other parties does not indicate any level of trust. Using the connection to establish a foundation of trust is the next step.</p>
<h2 id="general-messaging-constructs"><a class="toc-anchor" href="#general-messaging-constructs">§</a> General Messaging Constructs</h2>
<ul>
<li>Decorators (headers)</li>
<li>Threading</li>
<li>Message types / families</li>
<li>Reliable Delivery</li>
<li>Attachment/Payload Signatures</li>
<li>Timing</li>
<li>ACKs</li>
<li>Errors</li>
<li>Tracing / troubleshooting</li>
</ul>
<h2 id="attachments"><a class="toc-anchor" href="#attachments">§</a> Attachments</h2>
<h3 id="summary-2"><a class="toc-anchor" href="#summary-2">§</a> Summary</h3>
<p>DIDComm messages use a structured format with a defined schema and a small inventory of scalar data types (string, number, date, etc). However, it will be quite common for messages to supplement formalized exchange with arbitrary data–images, documents, or types of media not yet invented.</p>
<p>We need a way to “attach” such content to DIDComm messages. This method must be flexible, powerful, and usable without requiring new schema updates for every dynamic variation.</p>
<h3 id="reference-2"><a class="toc-anchor" href="#reference-2">§</a> Reference</h3>
<p>Attachments are contained within a list in the <code>attachments</code> header.</p>
<p>Each attachment is contained within the following structure.</p>
<ul>
<li><code>id</code>: Identifies attached content within the scope of a given message. Recommended on appended attachment descriptors. Possible but generally unused on embedded attachment descriptors. Never required if no references to the attachment exist; if omitted, then there is no way to refer to the attachment later in the thread, in error messages, and so forth. Because <code>id</code> is used to compose URIs, it is recommended that this name be brief and avoid spaces and other characters that require URI escaping.</li>
<li><code>description</code>: [optional] A human-readable description of the content.</li>
<li><code>filename</code>: A hint about the name that might be used if this attachment is persisted as a file. It is not required, and need not be unique. If this field is present and <code>mime-type</code> is not, the extension on the filename may be used to infer a MIME type.</li>
<li><code>format</code>: [optional] Describes the format of the attachment (ie)</li>
<li><code>mime_type</code>: [optional] Describes the MIME type of the attached content.</li>
<li><code>lastmod_time</code>: A hint about when the content in this attachment was last modified.</li>
<li><code>byte_count</code>: [optional] mostly relevant when content is included by reference instead of by value. Lets the receiver guess how expensive it will be, in time, bandwidth, and storage, to fully fetch the attachment.</li>
<li><code>data</code>: A JSON object that gives access to the actual content of the attachment. Contains the following subfields:
<ul>
<li><code>jws</code>: [optional] A JSON Web Signature over the content of the attachment.</li>
<li><code>hash</code>: [optional] The hash of the content encoded in multi-hash format. Used as an integrity check for the attachment, and MUST be used if the data is referenced via the <code>links</code> data attribute.</li>
<li><code>links</code>: [optional] A list of zero or more locations at which the content may be fetched.</li>
<li><code>base64</code>: [optional]Base64-encoded data, when representing arbitrary content inline instead of via <code>links</code>.</li>
<li><code>jwe</code>: Already encrypted data in the form of a JWE.</li>
<li><code>json</code>: [optional] Directly embedded JSON data, when representing content inline instead of via <code>links</code>, and when the content is natively conveyable as JSON.</li>
</ul>
</li>
</ul>
<h3 id="example"><a class="toc-anchor" href="#example">§</a> Example</h3>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"&lt;sometype>"</span><span class="token punctuation">,</span>
    <span class="token property">"to"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"did:example:mediator"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token property">"attachment_id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>
        <span class="token property">"encrypted_details"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
            <span class="token property">"encrypted_to"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
            <span class="token property">"other_details"</span><span class="token operator">:</span> <span class="token string">"about attachment"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"attachments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
			<span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>
            <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"example b64 encoded attachment"</span><span class="token punctuation">,</span>
            <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            	<span class="token property">"base64"</span><span class="token operator">:</span> <span class="token string">"WW91ciBob3ZlcmNyYWZ0IGlzIGZ1bGwgb2YgZWVscw=="</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
			<span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">,</span>
            <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"example linked attachment"</span><span class="token punctuation">,</span>
            <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            	<span class="token property">"hash"</span><span class="token operator">:</span> <span class="token string">"&lt;multi-hash>"</span><span class="token punctuation">,</span>
                <span class="token property">"links"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"http://path/to/resource"</span><span class="token punctuation">]</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
			<span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"x"</span><span class="token punctuation">,</span>
            <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"example encrypted attachment"</span><span class="token punctuation">,</span>
            <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            	<span class="token property">"jwe"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                    <span class="token comment">//jwe json structure</span>
                <span class="token punctuation">}</span>
        	<span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="protocols"><a class="toc-anchor" href="#protocols">§</a> Protocols</h3>
<p>DIDComm serves as a foundational layer for the development of protocols. This spec does not include protocols themselves, but describes the basic requirements and foundational elements.</p>
<p>Each Protocol is uniquely identified by a Protocol Identifier URI, and contains one or more messages identified by a Message Type URI. In addition to serving as a unique identifier, the URIs may be used by a developer to locate documentation.</p>
<h4 id="protocol-identifier-uri"><a class="toc-anchor" href="#protocol-identifier-uri">§</a> Protocol Identifier URI</h4>
<p>A Protocol Identifier URI identifies protocol versions unambiguously.  Additionally, Protocol Identifier URIs may be used by a developer to locate documentation about a protocol.</p>
<p>The URI must be composed as follows:</p>
<pre><code>[doc-uri][delim][protocol-name]/[semver]
</code></pre>
<p>With ABNF:</p>
<pre class="language-ABNF"><code class="language-ABNF">protocol-identifier-uri = doc-uri delim protocol-name &quot;/&quot; semver
delim                   = &quot;?&quot; / &quot;/&quot; / &quot;&amp;&quot; / &quot;:&quot; / &quot;;&quot; / &quot;=&quot;
</code></pre>
<p>Its loose matcher regex is:</p>
<pre><code>(.*?)([a-z0-9._-]+)/(\d[^/]*)/?$
</code></pre>
<p>Example Protocol Type URIs:</p>
<pre><code>http://example.com/protocols?which=lets_do_lunch/1.0
http://example.com/protocols/lets_do_lunch/1.0
https://github.com/hyperledger/aries-toolbox/tree/master/docs/admin-invitations/0.1
</code></pre>
<p>The goals of this URI are, in descending priority:</p>
<ul>
<li>
<p>Code can use the URI to route messages to protocol
handlers using <a href="semver.md">semver rules</a>.</p>
</li>
<li>
<p>The definition of a protocol should be tied to the URI such
that it is semantically stable. This means that once version 1.0
of a protocol is defined, its definition <a href="semver.md">should not change in
ways that would break implementations</a>.</p>
</li>
<li>
<p>Developers can discover information about novel protocols, using
the URI to browse or search the web.</p>
</li>
</ul>
<p>The <code>doc-uri</code> portion is any URI that exposes documentation about
protocols. A developer should be able to browse to that URI and use human intelligence
to look up the named and versioned protocol.</p>
<h4 id="message-type-uri"><a class="toc-anchor" href="#message-type-uri">§</a> Message Type URI</h4>
<p>A <strong>Message Type URI</strong> identifies message types unambiguously.
Standardizing its format is important because it is parsed by agents that
will map messages to handlers–basically, code will look at this string and
say, “Do I have something that can handle this message type inside protocol
<em>X</em> version <em>Y</em>?” When that analysis happens, it must do more than compare
the string for exact equality; it may need to check for semver compatibility,
and it has to compare the protocol name and message type name ignoring case
and punctuation.</p>
<p>The URI MUST be composed as follows:</p>
<pre><code>[protocol-identifier-uri] / [message-type-name]
</code></pre>
<p>With ABNF:</p>
<pre class="language-ABNF"><code class="language-ABNF">message-type-uri  = protocol-identifier-uri &quot;/&quot; message-type-name
protocol-identifier-uri = doc-uri delim protocol-name &quot;/&quot; semver
delim                   = &quot;?&quot; / &quot;/&quot; / &quot;&amp;&quot; / &quot;:&quot; / &quot;;&quot; / &quot;=&quot;
protocol-name     = identifier
protocol-version  = semver
message-type-name = identifier
identifier        = alpha *(*(alphanum / &quot;_&quot; / &quot;-&quot; / &quot;.&quot;) alphanum)
</code></pre>
<p>It can be loosely matched and parsed with the following regex:</p>
<pre><code>    (.*?)([a-z0-9._-]+)/(\d[^/]*)/([a-z0-9._-]+)$
</code></pre>
<p>A match will have captures groups of (1) = <code>doc-uri</code>, (2) = <code>protocol-name</code>,
(3) = <code>protocol-version</code>, and (4) = <code>message-type-name</code>.</p>
<p>The goals of this URI are, in descending priority:</p>
<ul>
<li>Use of the <code>protocol-identifier-uri</code> portion as described above.</li>
<li>Optionally and preferably, the full URI may produce a page of documentation about the specific message type, with no human mediation involved.</li>
</ul>
<p>Example Message Type URIs:</p>
<pre><code>http://example.com/protocols?which=lets_do_lunch/1.0/proposal
http://example.com/protocols/lets_do_lunch/1.0/proposal
did:example:1234567890;spec/trust_ping/1.0/ping
https://github.com/hyperledger/aries-toolbox/tree/master/docs/admin-invitations/0.1/create-invitation
</code></pre>
<h2 id="out-of-band-messages"><a class="toc-anchor" href="#out-of-band-messages">§</a> Out Of Band Messages</h2>
<h4 id="url-qr-codes"><a class="toc-anchor" href="#url-qr-codes">§</a> URL &amp; QR Codes</h4>
<p>When passing a DIDComm Message between two parties, it is often useful to present a message in the form of a URL or encoded into the form of a QR code for scanning with a smartphone or other camera. The format for a QR code is simply the encoded URL form of a message.</p>
<h5 id="privacy-considerations-2"><a class="toc-anchor" href="#privacy-considerations-2">§</a> Privacy Considerations</h5>
<p>Any information passed via a URL or QR code is unencrypted, and may be observed by another party. This lack of privacy must be minded in two different ways.</p>
<p>First, no private information may be passed in the message. Private information should be passed between parties in encrypted messages only. Any protocol message that contains private information should not be passed via URL or QR code.</p>
<p>Second, any identifiers passed in a message sent via URL or QR code must no longer be considered private. Any DID used or other identifier no longer considered private MUST be rotated over a secure connection if privacy is required.</p>
<h5 id="message-correlation"><a class="toc-anchor" href="#message-correlation">§</a> Message Correlation</h5>
<p>The <code>id</code> of the message passed in a URL or a QR code is used to as the <code>thread_id</code> on a response sent by the recipient of this message. The response recipient can use the <code>thread_id</code> to correlate it with the original message.</p>
<h5 id="messages-2"><a class="toc-anchor" href="#messages-2">§</a> Messages</h5>
<p>Each message passed this way must be contained within an <code>out-of-band</code> message, as described below.</p>
<p>The out-of-band protocol a single message that is sent by the <em>sender</em>.</p>
<h4 id="invitation-httpsdidcommorgout-of-bandverinvitation"><a class="toc-anchor" href="#invitation-httpsdidcommorgout-of-bandverinvitation">§</a> Invitation: <code>https://didcomm.org/out-of-band/%VER/invitation</code></h4>
<pre class="language-jsonc"><code class="language-jsonc">{
  &quot;@type&quot;: &quot;https://didcomm.org/out-of-band/%VER/invitation&quot;,
  &quot;@id&quot;: &quot;&lt;id used for context as pthid&gt;&quot;,
  &quot;goal_code&quot;: &quot;issue-vc&quot;,
  &quot;goal&quot;: &quot;To issue a Faber College Graduate credential&quot;,
  &quot;accept&quot;: [
    &quot;didcomm/v2&quot;,
    &quot;didcomm/aip2;env=rfc587&quot;
  ],
  &quot;attachments&quot;: [
    {
        &quot;@id&quot;: &quot;request-0&quot;,
        &quot;mime-type&quot;: &quot;application/json&quot;,
        &quot;data&quot;: {
            &quot;json&quot;: &quot;&lt;json of protocol message&gt;&quot;
        }
    }
  ]
}
</code></pre>
<p>The items in the message are:</p>
<ul>
<li><code>@type</code> - the DIDComm message type</li>
<li><code>@id</code> - the unique ID of the message. The ID should be used as the <strong>parent</strong> thread ID (<code>pthid</code>) for the response message, rather than the more common thread ID (<code>thid</code>) of the response message. This enables multiple uses of a single out-of-band message.</li>
<li><code>goal_code</code> - [optional] a self-attested code the receiver may want to display to the user or use in automatically deciding what to do with the out-of-band message.</li>
<li><code>goal</code> - [optional] a self-attested string that the receiver may want to display to the user about the context-specific goal of the out-of-band message.</li>
<li><code>accept</code> - [optional] an array of media (aka mime) types in the order of preference of the sender that the receiver can use in responding to the message.
If <code>accept</code> is not specified, the receiver uses its preferred choice to respond to the message.
Please see <a href="#message-types">Message Types</a> for details about media types.</li>
<li><code>attachments</code> - an array of attachments that will contain the invitation messages in order of preference that the receiver can using in responding to the message. Each message in the array is a rough equivalent of the others, an all are in pursuit of the stated <code>goal</code> and <code>goal_code</code>. Only one of the messages should be chosen and acted upon.
<ul>
<li>While the JSON form of the attachment is used in the example above, the sender could choose to use the base64 form.</li>
</ul>
</li>
</ul>
<p>When encoding a message in a URL or QR code, the <em>sender</em> does not know which protocols are supported by the <em>recipient</em> of the message. Encoding multiple alternative messages is a form of optimistic protocol negotiation that allows multiple supported protocols without coordination</p>
<h5 id="standard-message-encoding"><a class="toc-anchor" href="#standard-message-encoding">§</a> Standard Message Encoding</h5>
<p>Using a standard message encoding allows for easier interoperability between multiple projects and software platforms. Using a URL for that standard encoding provides a built in fallback flow for users who are unable to automatically process the message. Those new users will load the URL in a browser as a default behavior, and may be presented with instructions on how to install software capable of processing the message. Already onboarded users will be able to process the message without loading in a browser via mobile app URL capture, or via capability detection after being loaded in a browser.</p>
<p>The standard message format is a URL with a Base64URLEncoded plaintext JWM json object as a query parameter.</p>
<p>The URL format is as follows, with some elements described below:</p>
<pre class="language-text"><code class="language-text">https://&lt;domain&gt;/&lt;path&gt;?_oob=&lt;encodedplaintextjwm&gt;
</code></pre>
<p><code>&lt;domain&gt;</code> and <code>&lt;path&gt;</code> should be kept as short as possible, and the full URL should return human readable instructions when loaded in a browser. This is intended to aid new users. The <code>_oob</code> query parameter is required and is reserved to contain the DIDComm message string. Additional path elements or query parameters are allowed, and can be leveraged to provide coupons or other promise of payment for new users.</p>
<blockquote>
<p><code>_oob</code> is a shortened form of Out of Band, and was chosen to not conflict with query parameter names in use at a particular domain. When the query parameter is detected, it may be assumed to be an Out Of Band message with a reasonably high confidence.</p>
</blockquote>
<blockquote>
<p>To do: We need to rationalize this approach <code>https://</code> approach with the use of a special protocol (e.g. <code>didcomm://</code>) that will enable handling of the URL on mobile devices to automatically invoke an installed app on both Android and iOS. A user must be able to process the out-of-band message on the device of the agent (e.g. when the mobile device can’t scan the QR code because it is on a web page on device).</p>
</blockquote>
<p>The <code>&lt;encodedplaintextjwm&gt;</code> is a JWM plaintext message that has been base64-url encoded.</p>
<pre class="language-javascript"><code class="language-javascript">encodedplaintextjwm <span class="token operator">=</span> <span class="token function">b64urlencode</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>plaintextjwm<span class="token operator">></span><span class="token punctuation">)</span>
</code></pre>
<p>During encoding, whitespace from the json string should be eliminated to keep the resulting out-of-band message string as short as possible.</p>
<h5 id="example-out-of-band-message-encoding"><a class="toc-anchor" href="#example-out-of-band-message-encoding">§</a> Example Out-of-Band Message Encoding</h5>
<p>Invitation:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/out-of-band/0.1/invitation"</span><span class="token punctuation">,</span>
  <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"69212a3a-d068-4f9d-a2dd-4741bca89af3"</span><span class="token punctuation">,</span>
  <span class="token property">"from"</span><span class="token operator">:</span> <span class="token string">"did:example:alice"</span><span class="token punctuation">,</span>
  <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"goal_code"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
      <span class="token property">"goal"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"attachments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
          <span class="token property">"@id"</span><span class="token operator">:</span> <span class="token string">"request-0"</span><span class="token punctuation">,</span>
          <span class="token property">"mime-type"</span><span class="token operator">:</span> <span class="token string">"application/json"</span><span class="token punctuation">,</span>
          <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"json"</span><span class="token operator">:</span> <span class="token string">"&lt;json of protocol message>"</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Whitespace removed:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"https://didcomm.org/out-of-band/0.1/invitation"</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"69212a3a-d068-4f9d-a2dd-4741bca89af3"</span><span class="token punctuation">,</span><span class="token property">"from"</span><span class="token operator">:</span><span class="token string">"did:example:alice"</span><span class="token punctuation">,</span><span class="token property">"body"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"goal_code"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token property">"goal"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token property">"attachments"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"@id"</span><span class="token operator">:</span><span class="token string">"request-0"</span><span class="token punctuation">,</span><span class="token property">"mime-type"</span><span class="token operator">:</span><span class="token string">"application/json"</span><span class="token punctuation">,</span><span class="token property">"data"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"json"</span><span class="token operator">:</span><span class="token string">"&lt;json of protocol message>"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre>
<p>Base 64 URL Encoded:</p>
<pre class="language-text"><code class="language-text">eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8wLjEvaW52aXRhdGlvbiIsImlkIjoiNjkyMTJhM2EtZDA2OC00ZjlkLWEyZGQtNDc0MWJjYTg5YWYzIiwiZnJvbSI6ImRpZDpleGFtcGxlOmFsaWNlIiwiYm9keSI6eyJnb2FsX2NvZGUiOiIiLCJnb2FsIjogIiIsInJlcXVlc3R-YXR0YWNoIjpbeyJAaWQiOiJyZXF1ZXN0LTAiLCJtaW1lLXR5cGUiOiJhcHBsaWNhdGlvbi9qc29uIiwiZGF0YSI6eyJqc29uIjoiPGpzb24gb2YgcHJvdG9jb2wgbWVzc2FnZT4ifX1dfX0=
</code></pre>
<p>Example URL:</p>
<pre class="language-text"><code class="language-text">http://example.com/path?_oob=eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8wLjEvaW52aXRhdGlvbiIsImlkIjoiNjkyMTJhM2EtZDA2OC00ZjlkLWEyZGQtNDc0MWJjYTg5YWYzIiwiZnJvbSI6ImRpZDpleGFtcGxlOmFsaWNlIiwiYm9keSI6eyJnb2FsX2NvZGUiOiIiLCJnb2FsIjogIiIsInJlcXVlc3R-YXR0YWNoIjpbeyJAaWQiOiJyZXF1ZXN0LTAiLCJtaW1lLXR5cGUiOiJhcHBsaWNhdGlvbi9qc29uIiwiZGF0YSI6eyJqc29uIjoiPGpzb24gb2YgcHJvdG9jb2wgbWVzc2FnZT4ifX1dfX0=
</code></pre>
<p>DIDComm message URLs can be transferred via any method that can send text, including an email, SMS, posting on a website, or QR Code.</p>
<p>Example Email Message:</p>
<pre class="language-email"><code class="language-email">To: alice@example.com
From: studentrecords@example.com
Subject: Your request to connect and receive your graduate verifiable credential

Dear Alice,

To receive your Faber College graduation certificate, click here to [connect](http://example.com/path?_oob=eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8wLjEvaW52aXRhdGlvbiIsImlkIjoiNjkyMTJhM2EtZDA2OC00ZjlkLWEyZGQtNDc0MWJjYTg5YWYzIiwiZnJvbSI6ImRpZDpleGFtcGxlOmFsaWNlIiwiYm9keSI6eyJnb2FsX2NvZGUiOiIiLCJnb2FsIjogIiIsInJlcXVlc3R-YXR0YWNoIjpbeyJAaWQiOiJyZXF1ZXN0LTAiLCJtaW1lLXR5cGUiOiJhcHBsaWNhdGlvbi9qc29uIiwiZGF0YSI6eyJqc29uIjoiPGpzb24gb2YgcHJvdG9jb2wgbWVzc2FnZT4ifX1dfX0= with us, or paste the following into your browser:

http://example.com/path?_oob=eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8wLjEvaW52aXRhdGlvbiIsImlkIjoiNjkyMTJhM2EtZDA2OC00ZjlkLWEyZGQtNDc0MWJjYTg5YWYzIiwiZnJvbSI6ImRpZDpleGFtcGxlOmFsaWNlIiwiYm9keSI6eyJnb2FsX2NvZGUiOiIiLCJnb2FsIjogIiIsInJlcXVlc3R-YXR0YWNoIjpbeyJAaWQiOiJyZXF1ZXN0LTAiLCJtaW1lLXR5cGUiOiJhcHBsaWNhdGlvbi9qc29uIiwiZGF0YSI6eyJqc29uIjoiPGpzb24gb2YgcHJvdG9jb2wgbWVzc2FnZT4ifX1dfX0=

If you don't have an identity agent for holding credentials, you will be given instructions on how you can get one.

Thanks,

Faber College
Knowledge is Good
</code></pre>
<p>Example URL encoded as a QR Code:</p>
<p><img src=".//collateral/out_of_band_exampleqr.png" alt="Example QR Code"></p>
<h5 id="short-url-message-retrieval"><a class="toc-anchor" href="#short-url-message-retrieval">§</a> Short URL Message Retrieval</h5>
<p>It seems inevitable that the length of some DIDComm messages will be too long to produce a useable QR code. Techniques to avoid unusable QR codes have been presented above, including using attachment links for requests, minimizing the routing of the response and eliminating unnecessary whitespace in the JSON. However, at some point a <em>sender</em> may need generate a very long URL. In that case, a short URL message retrieval redirection should be implemented by the sender as follows:</p>
<ul>
<li>The sender should generate and track a GUID for the out-of-band message URL.</li>
<li>The shortened version should be:
<ul>
<li><code>https://example.com/path?_oobid=5f0e3ffb-3f92-4648-9868-0d6f8889e6f3</code></li>
<li>Note the replacement of the query parameter <code>_oob</code> with <code>_oobid</code> when using shortened URL.</li>
</ul>
</li>
<li>On receipt of this form of message, the agent must do an HTTP GET to retrieve the associated encoded  message.
<ul>
<li>A sender may want to wait to generate the full invitation until the redirection event of the shortened URL to the full length form dynamic, so a single QR code can be used for distinct messages.</li>
</ul>
</li>
</ul>
<p>A usable QR code will always be able to be generated from the shortened form of the URL.</p>
<p>Note: Due to the privacy implications, a standard URL shortening service SHOULD NOT be used.</p>
<h2 id="discover-features-protocol-10"><a class="toc-anchor" href="#discover-features-protocol-10">§</a> Discover Features Protocol 1.0</h2>
<h3 id="summary-3"><a class="toc-anchor" href="#summary-3">§</a> Summary</h3>
<p>Describes how agents can query one another to discover which features
it supports, and to what extent.</p>
<h3 id="motivation"><a class="toc-anchor" href="#motivation">§</a> Motivation</h3>
<p>Though some agents will support just one protocol and will be
statically configured to interact with just one other party, many
exciting uses of agents are more dynamic and unpredictable. When
Alice and Bob meet, they won’t know in advance which features are
supported by one another’s agents. They need a way to find out.</p>
<p>Disclosing features in this manner has a significant privacy benefit over endpoint disclosures contained in a DID Document published to a Verifiable Data Registry (VDR). Using the single DIDComm endpoint published in the document and this protocol, features can be selectively disclosed to other parties at the owner’s discretion. The problem of anonymous scanning and fingerprinting enabled with VDR disclosures is solved in a privacy preserving way.</p>
<h3 id="reference-3"><a class="toc-anchor" href="#reference-3">§</a> Reference</h3>
<p>This RFC introduces a protocol for discussing the protocols an agent
can handle. The identifier for the message family used by this protocol is
<code>discover-features</code>, and the fully qualified URI for its definition is:</p>
<pre><code>https://didcomm.org/discover-features/1.0
</code></pre>
<h4 id="roles-2"><a class="toc-anchor" href="#roles-2">§</a> Roles</h4>
<p>There are two roles in the <code>discover-features</code> protocol: <code>requester</code> and
<code>responder</code>. The requester asks the responder about the protocols it
supports, and the responder answers. Each role uses a single message type.</p>
<h4 id="states-2"><a class="toc-anchor" href="#states-2">§</a> States</h4>
<p>This is a classic two-step request~response interaction, so it uses the
predefined state machines for any <code>requester</code> and <code>responder</code>:</p>
<p><a href="https://docs.google.com/spreadsheets/d/1smY8qhG1qqGs0NH9g2hV4b7mDqrM6MIsmNI93tor2qk/edit"><img src="../collateral/routing-state-machines.png" alt="state machines"></a></p>
<h4 id="messages-3"><a class="toc-anchor" href="#messages-3">§</a> Messages</h4>
<h6 id="query-message-type"><a class="toc-anchor" href="#query-message-type">§</a> <code>query</code> Message Type</h6>
<p>A <code>discover-features/query</code> message looks like this:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/discover-features/1.0/query"</span><span class="token punctuation">,</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"yWd8wfYzhmuXX3hmLNaV5bVbAjbWaU"</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"query"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/tictactoe/1.*"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Query messages say, “Please tell me what your capabilities are with
respect to the protocols that match this string.” This particular example
asks if another agent knows any 1.x versions of the tictactoe protocol.</p>
<p>The <code>query</code> field may use the * wildcard. By itself, a query with just
the wildcard says, “I’m interested in anything you want to share with
me.” But usually, this wildcard will be to match a prefix that’s a little
more specific, as in the example that matches any 1.x version.</p>
<p>Any agent may send another agent this message type at any time.
Implementers of agents that intend to support dynamic relationships
and rich features are <em>strongly</em> encouraged to implement support
for this message, as it is likely to be among the first messages
exchanged with a stranger.</p>
<h6 id="disclose-message-type"><a class="toc-anchor" href="#disclose-message-type">§</a> <code>disclose</code> Message Type</h6>
<p>A <code>discover-features/disclose</code> message looks like this:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/discover-features/1.0/disclose"</span><span class="token punctuation">,</span>
    <span class="token property">"thread_id"</span><span class="token operator">:</span> <span class="token string">"yWd8wfYzhmuXX3hmLNaV5bVbAjbWaU"</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token property">"protocols"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
                <span class="token property">"ptid"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/tictactoe/1.0"</span><span class="token punctuation">,</span>
                <span class="token property">"roles"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"player"</span><span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>protocols</code> field is a JSON array of <strong>protocol support descriptor</strong>
objects that match the query. Each descriptor has a <code>pid</code> that contains
a protocol version (fully qualified message family identifier such as
<code>https://didcomm.org/tictactoe/1.0</code>), plus a <code>roles</code>
array that enumerates the roles the responding agent
can play in the associated protocol.</p>
<p>Response messages say, “Here are some protocols I support that matched
your query, and some things I can do with each one.”</p>
<h6 id="sparse-responses"><a class="toc-anchor" href="#sparse-responses">§</a> Sparse Responses</h6>
<p>Responses do not have to contain exhaustive detail. For example, the following
response is probably just as good:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/discover-features/1.0/disclose"</span><span class="token punctuation">,</span>
  <span class="token property">"thread_id"</span><span class="token operator">:</span> <span class="token string">"yWd8wfYzhmuXX3hmLNaV5bVbAjbWaU"</span><span class="token punctuation">,</span>
  <span class="token property">"protocols"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span><span class="token property">"ptid"</span><span class="token operator">:</span> <span class="token string">"https://didcomm.org/tictactoe/1.0"</span><span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The reason why less detail probably suffices is that agents do not need to
know everything about one another’s implementations in order to start an
interaction–usually the flow will organically reveal what’s needed. For
example, the <code>outcome</code> message in the <code>tictactoe</code> protocol isn’t needed
until the end, and is optional anyway. Alice can start a tictactoe game
with Bob and will eventually see whether he has the right idea about
<code>outcome</code> messages.</p>
<p>The missing <code>roles</code> in this response does not say, “I support no roles
in this protocol.” It says, “I support the protocol but
I’m providing no detail about specific roles.”</p>
<p>Even an empty <code>protocols</code> map does not say, “I support no protocols
that match your query.” It says, “I’m not telling you that I support any
protocols that match your query.” An agent might not tell another that
it supports a protocol for various reasons, including: the trust that
it imputes to the other party based on cumulative interactions so far,
whether it’s in the middle of upgrading a plugin, whether it’s currently
under high load, and so forth. And responses to a <code>discover-features</code> request are
not guaranteed to be true forever; agents can be upgraded or downgraded,
although they probably won’t churn in their protocol support from moment
to moment.</p>
<h4 id="privacy-considerations-3"><a class="toc-anchor" href="#privacy-considerations-3">§</a> Privacy Considerations</h4>
<p>Because the regex in a <code>request</code> message can be very inclusive, the <code>discover-features</code>
protocol could be used to mine information suitable for agent fingerprinting,
in much the same way that browser fingerprinting works. This is antithetical
to the ethos of our ecosystem, and represents bad behavior. Agents should
use <code>discover-features</code> to answer legitimate questions, and not to build detailed
profiles of one another. However, fingerprinting may be attempted
anyway.</p>
<p>For agents that want to maintain privacy, several best practices are
recommended:</p>
<h6 id="follow-selective-disclosure"><a class="toc-anchor" href="#follow-selective-disclosure">§</a> Follow selective disclosure.</h6>
<p>Only reveal supported features based on trust in the relationship.
Even if you support a protocol, you may not wish to use it in
every relationship. Don’t tell others about protocols you do
not plan to use with them.</p>
<p>Patterns are easier to see in larger data samples. However, a pattern
of ultra-minimal data is also a problem, so use good judgment about
how forthcoming to be.</p>
<h2 id="trust-ping-protocol-10"><a class="toc-anchor" href="#trust-ping-protocol-10">§</a> Trust Ping Protocol 1.0</h2>
<p>A standard way for agents to test connectivity,
responsiveness, and security of a DIDComm channel.</p>
<h3 id="motivation-2"><a class="toc-anchor" href="#motivation-2">§</a> Motivation</h3>
<p>Agents are distributed. They are not guaranteed to be
connected or running all the time. They support a
variety of transports, speak a variety of protocols,
and run software from many different vendors.</p>
<p>This can make it very difficult to prove that two
agents have a functional pairwise channel. Troubleshooting
connectivity, responsiveness, and security is vital.</p>
<h3 id="reference-4"><a class="toc-anchor" href="#reference-4">§</a> Reference</h3>
<p>This protocol is analogous to the familiar <code>ping</code>
command in networking–but because it operates
over DIDComm, it is transport
agnostic and asynchronous, and it can produce insights
into privacy and security that a regular ping
cannot.</p>
<h4 id="roles-3"><a class="toc-anchor" href="#roles-3">§</a> Roles</h4>
<p>There are two parties in a trust ping: the <code>sender</code>
and the <code>receiver</code>. The sender initiates the trust
ping. The receiver responds. If the receiver wants
to do a ping of their own, they can, but this is a
new interaction in which they become the sender.</p>
<h4 id="protocol-type-uri"><a class="toc-anchor" href="#protocol-type-uri">§</a> Protocol Type URI</h4>
<p><code>https://didcomm.org/trust_ping/1.0</code></p>
<h4 id="messages-4"><a class="toc-anchor" href="#messages-4">§</a> Messages</h4>
<h5 id="ping"><a class="toc-anchor" href="#ping">§</a> ping</h5>
<p>The trust ping interaction begins when <code>sender</code>
creates a <code>ping</code> message like this:</p>
<pre class="language-JSON"><code class="language-JSON">{
  &quot;type&quot;: &quot;https://didcomm.org/trust_ping/1.0/ping&quot;,
  &quot;id&quot;: &quot;518be002-de8e-456e-b3d5-8fe472477a86&quot;,
  &quot;body&quot;: {
      &quot;response_requested&quot;: true
  }
}
</code></pre>
<p><strong>response_requested</strong>: default value is <code>true</code>. If false, the <code>sender</code> is not requesting a <code>ping_response</code> from the <code>receiver</code>. If <code>true</code>, the <code>sender</code> is requesting a response.</p>
<h5 id="ping_response"><a class="toc-anchor" href="#ping_response">§</a> ping_response</h5>
<p>When the message arrives at the receiver, assuming that <code>response_requested</code>
is not <code>false</code>, the receiver should reply as quickly as possible with a
<code>ping_response</code> message that looks like this:</p>
<pre class="language-JSON"><code class="language-JSON">{
  &quot;type&quot;: &quot;https://didcomm.org/trust_ping/1.0/ping_response&quot;,
  &quot;id&quot;: &quot;e002518b-456e-b3d5-de8e-7a86fe472847&quot;,
  &quot;thread_id&quot;: &quot;518be002-de8e-456e-b3d5-8fe472477a86&quot;
}
</code></pre>
<h4 id="trust"><a class="toc-anchor" href="#trust">§</a> Trust</h4>
<p>This is the “<strong>trust</strong> ping protocol”, not just the “ping protocol.”
The “trust” in its name comes from several features that the interaction
gains by virtue of the properties of the DIDComm messages. A ping and response verify to both parties that the necessary encryption is in place and working properly for the messages to be understood.</p>
<h2 id="reference-implementation"><a class="toc-anchor" href="#reference-implementation">§</a> Reference Implementation</h2>
<ul>
<li>Features</li>
<li>Usage</li>
</ul>
<h2 id="future-proofing"><a class="toc-anchor" href="#future-proofing">§</a> Future-Proofing</h2>
<h3 id="versioning"><a class="toc-anchor" href="#versioning">§</a> Versioning</h3>
<p>This version of the standard is known as “DIDComm v2” — acknowledging the fact that a <a href="https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0005-didcomm/README.md">v1 generation of DIDComm specs</a> was incubated under the Hyperledger Aries project umbrella. The v1 specs are close conceptual cousins, but use a slightly different encryption envelope, and base their plaintext format on arbitrary JSON instead of JWMs.</p>
<p>Future evolutions of the spec will follow <a href="https://semver.org">semver</a> conventions. Minor updates that add features without breaking compatibility will carry a minor version number update: 2.1, 2.2, and so forth. Breaking changes will prompt a major version change.</p>
<h3 id="extensions"><a class="toc-anchor" href="#extensions">§</a> Extensions</h3>
<p>The general mechanism for DIDComm extensibility is the development of DIDComm protocols. In the case where extensibility requires a modification to the base DIDComm spec itself, a DIDComm extension is to be used. An extension adds a self-contained set of conventions or features. Support for DIDComm extensions is optional.</p>
<p>Each DIDComm extension is described in a specification of its own. Software that implements a DIDComm Extension in addition to the DIDComm spec will indicate so via link to the extension spec.</p>
<h3 id="future-work"><a class="toc-anchor" href="#future-work">§</a> Future Work</h3>
<h4 id="additional-encodings"><a class="toc-anchor" href="#additional-encodings">§</a> Additional Encodings</h4>
<p>DIDComm Messages are JSON encoded (based on the JOSE family of specs) at the encryption, signature, and content level. Future encodings might introduce binary serializations. Each innovation like this MUST specify a deterministic and reliable method for indicating the alternative encoding used.</p>
<h3 id="beyond-messaging"><a class="toc-anchor" href="#beyond-messaging">§</a> Beyond Messaging</h3>
<p>This is a DIDComm <em>messaging</em> spec. Security, privacy, routing, and metadata concepts from this spec could be adapted to other communication styles, including multicast/broadcast and streaming. This will create sister specs to DIDComm Messaging, rather than evolving DIDComm Messaging itself.</p>
<h3 id="post-quantum-crypto"><a class="toc-anchor" href="#post-quantum-crypto">§</a> Post-Quantum Crypto</h3>
<p>The designers of DIDComm are aware that DIDComm’s cryptographic methods will need to be upgraded when quantum computing matures. This is because DIDComm makes heavy use of asymmetric elliptic curve mechanisms that depend on the discrete logarithm problem; this computational hardness is likely to be vulnerable to quantum cracking. Similar risks will drive upgrades to TLS, Ethereum, Bitcoin, and many other systems that are considered highly secure today.</p>
<p>Some modest preparations for quantum-resistant DIDComm have already begun. DIDComm is able to use arbitrary DID methods, which should allow approaches that are quantum-secure without changing the general pattern of DIDComm’s interaction with key management technology.</p>
<p>Libraries that provide quantum-resistant algorithms for signing and encryption are now available, but research is needed to determine which approaches are worthy of broad adoption. This is the subject of <a href="https://csrc.nist.gov/projects/post-quantum-cryptography">an ongoing project sponsored by NIST</a>, and of <a href="https://ec.europa.eu/digital-single-market/en/news/future-quantum-eu-countries-plan-ultra-secure-communication-network">a similar project in the EU</a>.</p>
<p>We expect to update the DIDComm Messaging spec as these projects release mature recommendations and the cryptographic libraries they vet achieve adoption. It is not yet clear whether this will require a breaking change to DIDComm’s encryption envelope or signing formats.</p>
<h2 id="references"><a class="toc-anchor" href="#references">§</a> References</h2>
<ul>
<li>DID spec</li>
<li>OSI stack (for comparison purposes)</li>
<li>Kim Cameron’s 7 Laws</li>
</ul>

              </article>    

            </main>

            <slide-panels id="slidepanels">
              <slide-panel id="repo_issues" options="right">
                <header class="panel-header">
                  <span>
                    <svg icon><use xlink:href="#github"></use></svg>
                    <span issue-count></span>
                  </span>
                  <span class="repo-issue-toggle" panel-toggle="repo_issues">✕</span>
                </header>
                <ul id="repo_issue_list"></ul>
              </slide-panel>

              <slide-panel id="toc">
                <header class="panel-header">
                  <span>Table of Contents</span>
                  <span panel-toggle="toc">✕</span>
                </header>
                <div id="toc_list">
                  <ul class="toc">
<li><a href="#purpose-and-scope">Purpose and Scope</a>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#specific-requirements">Specific Requirements</a></li>
<li><a href="#ramifications">Ramifications</a>
<ul>
<li><a href="#message-based-asynchronous-and-simplex">Message-Based, Asynchronous, and Simplex</a></li>
<li><a href="#message-level-security-reciprocal-authentication">Message-Level Security, Reciprocal Authentication</a></li>
</ul>
</li>
<li><a href="#processing-model">Processing Model</a></li>
</ul>
</li>
<li><a href="#message-types">Message Types</a>
<ul>
<li><a href="#media-types">Media Types</a></li>
<li><a href="#didcomm-plaintext-messages">DIDComm Plaintext Messages</a></li>
<li><a href="#didcomm-signed-message">DIDComm Signed Message</a></li>
<li><a href="#didcomm-encrypted-message">DIDComm Encrypted Message</a></li>
</ul>
</li>
<li><a href="#negotiating-compatibility">Negotiating Compatibility</a>
<ul>
<li><a href="#defined-profiles">Defined Profiles</a></li>
</ul>
</li>
<li><a href="#plaintext-message-structure">Plaintext Message Structure</a>
<ul>
<li><a href="#message-headers">Message Headers</a>
<ul>
<li><a href="#simple-vs-structured">Simple vs. Structured</a></li>
<li><a href="#relationship-to-json-ld">Relationship to JSON-LD</a></li>
</ul>
</li>
<li><a href="#did-rotation">DID Rotation</a>
<ul>
<li><a href="#jwt-details">JWT Details</a></li>
<li><a href="#example-message-rotating-did">Example Message Rotating DID</a></li>
<li><a href="#rotation-limitations">Rotation Limitations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sender-authenticated-encryption">Sender Authenticated Encryption</a></li>
<li><a href="#anonymous-encryption">Anonymous Encryption</a></li>
<li><a href="#curves-and-content-encryption-algorithms">Curves and Content Encryption Algorithms</a></li>
<li><a href="#key-wrapping-algorithms">Key Wrapping Algorithms</a></li>
<li><a href="#media-types-2">Media Types</a></li>
<li><a href="#perfect-forward-secrecy">Perfect Forward Secrecy</a></li>
<li><a href="#key-ids-kid-and-skid-headers-references-in-the-did-document">Key IDs <code>kid</code> and <code>skid</code> headers references in the DID document</a></li>
<li><a href="#protecting-the-skid-header">Protecting the <code>skid</code> header</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#message-signing">Message Signing</a>
<ul>
<li><a href="#algorithms">Algorithms</a></li>
<li><a href="#construction">Construction</a></li>
<li><a href="#verification">Verification</a></li>
<li><a href="#application">Application</a>
<ul>
<li><a href="#non-repudiation">Non-Repudiation</a></li>
<li><a href="#tamper-resistant-oob-messages">Tamper Resistant OOB Messages</a></li>
<li><a href="#did-anchoring">DID Anchoring</a></li>
</ul>
</li>
<li><a href="#examples-2">Examples</a></li>
</ul>
</li>
<li><a href="#routing">Routing</a>
<ul>
<li><a href="#routing-protocol">Routing Protocol</a>
<ul>
<li><a href="#name-and-version">Name and Version</a></li>
<li><a href="#roles">Roles</a></li>
<li><a href="#states">States</a></li>
<li><a href="#messages">Messages</a></li>
<li><a href="#rewrapping">Rewrapping</a></li>
</ul>
</li>
<li><a href="#sender-forward-process">Sender Forward Process</a></li>
<li><a href="#mediator-process">Mediator Process</a></li>
<li><a href="#did-document-keys">DID Document Keys</a></li>
<li><a href="#did-document-service-endpoint">DID Document Service Endpoint</a>
<ul>
<li><a href="#multiple-endpoints">Multiple Endpoints</a></li>
<li><a href="#alternative-endpoints">Alternative Endpoints</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#transports">Transports</a>
<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#delivery">Delivery</a></li>
<li><a href="#reference">Reference</a>
<ul>
<li><a href="#https">HTTP(S)</a></li>
<li><a href="#websocket">WebSocket</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced-message-passing">Advanced Message Passing</a>
*
<ul>
<li><a href="#embedded-messages">Embedded Messages</a></li>
<li><a href="#connections">Connections</a></li>
</ul>
</li>
<li><a href="#general-messaging-constructs">General Messaging Constructs</a></li>
<li><a href="#attachments">Attachments</a>
<ul>
<li><a href="#summary-2">Summary</a></li>
<li><a href="#reference-2">Reference</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#protocols">Protocols</a>
<ul>
<li><a href="#protocol-identifier-uri">Protocol Identifier URI</a></li>
<li><a href="#message-type-uri">Message Type URI</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#out-of-band-messages">Out Of Band Messages</a>
*
<ul>
<li><a href="#url-qr-codes">URL &amp; QR Codes</a></li>
<li><a href="#invitation-httpsdidcommorgout-of-bandverinvitation">Invitation: <code>https://didcomm.org/out-of-band/%VER/invitation</code></a></li>
</ul>
</li>
<li><a href="#discover-features-protocol-10">Discover Features Protocol 1.0</a>
<ul>
<li><a href="#summary-3">Summary</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#reference-3">Reference</a>
<ul>
<li><a href="#roles-2">Roles</a></li>
<li><a href="#states-2">States</a></li>
<li><a href="#messages-3">Messages</a></li>
<li><a href="#privacy-considerations-3">Privacy Considerations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#trust-ping-protocol-10">Trust Ping Protocol 1.0</a>
<ul>
<li><a href="#motivation-2">Motivation</a></li>
<li><a href="#reference-4">Reference</a>
<ul>
<li><a href="#roles-3">Roles</a></li>
<li><a href="#protocol-type-uri">Protocol Type URI</a></li>
<li><a href="#messages-4">Messages</a></li>
<li><a href="#trust">Trust</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference-implementation">Reference Implementation</a></li>
<li><a href="#future-proofing">Future-Proofing</a>
<ul>
<li><a href="#versioning">Versioning</a></li>
<li><a href="#extensions">Extensions</a></li>
<li><a href="#future-work">Future Work</a>
<ul>
<li><a href="#additional-encodings">Additional Encodings</a></li>
</ul>
</li>
<li><a href="#beyond-messaging">Beyond Messaging</a></li>
<li><a href="#post-quantum-crypto">Post-Quantum Crypto</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>

                </div>
              </slide-panel>
              
            </slide-panels>

          </body>
          <script>window.specConfig = {"title":"DIDComm Messaging Specification","logo":"https://rawcdn.githack.com/decentralized-identity/decentralized-identity.github.io/a3ca39717e440302d1fd99a796e7f00e1c42eb2d/images/logo-flat.svg","logo_link":"https://identity.foundation","source":{"host":"github","account":"decentralized-identity","repo":"didcomm-messaging"},"output_path":"./docs/spec","spec_directory":"./docs/spec-files/","markdown_paths":["title.md","scope.md","requirements.md","processing_model.md","message_structure.md","encryption.md","signature.md","routing.md","transports.md","advanced_message_passing.md","connections.md","general_messaging_constructs.md","protocols.md","out_of_band.md","feature_discovery.md","trustping.md","reference_implementation.md","future_proofing.md","references.md"],"destination":"./docs/spec/","rootResourcePrefix":"./docs/","destinationResourcePrefix":"../"}</script>
          <script src="../spec-up/compiled/body.js" data-manual></script>
        </html>
      